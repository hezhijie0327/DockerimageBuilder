diff --git a/packages/web-crawler/src/crawImpl/index.ts b/packages/web-crawler/src/crawImpl/index.ts
index c58d77b2d8b9b..8aaa4a62625cb 100644
--- a/packages/web-crawler/src/crawImpl/index.ts
+++ b/packages/web-crawler/src/crawImpl/index.ts
@@ -2,12 +2,14 @@ import { browserless } from './browserless';
 import { jina } from './jina';
 import { naive } from './naive';
 import { search1api } from './search1api';
+import { tavily } from './tavily';
 
 export const crawlImpls = {
   browserless,
   jina,
   naive,
   search1api,
+  tavily,
 };
 
 export type CrawlImplType = keyof typeof crawlImpls;
diff --git a/packages/web-crawler/src/crawImpl/tavily.ts b/packages/web-crawler/src/crawImpl/tavily.ts
new file mode 100644
index 0000000000000..3f1f860e172ac
--- /dev/null
+++ b/packages/web-crawler/src/crawImpl/tavily.ts
@@ -0,0 +1,94 @@
+import { CrawlImpl, CrawlSuccessResult } from '../type';
+import { NetworkConnectionError, PageNotFoundError, TimeoutError } from '../utils/errorType';
+import { DEFAULT_TIMEOUT, withTimeout } from '../utils/withTimeout';
+
+interface TavilyResults {
+  images?: string[];
+  raw_content: string;
+  url: string;
+}
+
+interface TavilyFailedResults {
+  error?: string;
+  url: string;
+}
+
+interface TavilyResponse {
+  base_url: string;
+  failed_results?: TavilyFailedResults[];
+  response_time: number;
+  results: TavilyResults[];
+}
+
+export const tavily: CrawlImpl = async (url) => {
+  // Get API key from environment variable
+  const apiKey = process.env.TAVILY_API_KEY;
+
+  let res: Response;
+
+  try {
+    res = await withTimeout(
+      fetch('https://api.tavily.com/extract', {
+        body: JSON.stringify({
+          extract_depth: process.env.TAVILY_EXTRACT_DEPTH || 'basic', // basic or advanced
+          include_images: false,
+          urls: url,
+        }),
+        headers: {
+          'Authorization': !apiKey ? '' : `Bearer ${apiKey}`,
+          'Content-Type': 'application/json',
+        },
+        method: 'POST',
+      }),
+      DEFAULT_TIMEOUT,
+    );
+  } catch (e) {
+    const error = e as Error;
+    if (error.message === 'fetch failed') {
+      throw new NetworkConnectionError();
+    }
+
+    if (error instanceof TimeoutError) {
+      throw error;
+    }
+
+    throw e;
+  }
+
+  if (!res.ok) {
+    if (res.status === 404) {
+      throw new PageNotFoundError(res.statusText);
+    }
+
+    throw new Error(`Tavily request failed with status ${res.status}: ${res.statusText}`);
+  }
+
+  try {
+    const data = (await res.json()) as TavilyResponse;
+
+    if (!data.results || data.results.length === 0) {
+      console.warn( 'Tavily API returned no results for URL:', url )
+      return
+    }
+
+    const firstResult = data.results[0];
+
+    // Check if content is empty or too short
+    if (!firstResult.raw_content || firstResult.raw_content.length < 100) {
+      return;
+    }
+
+    return {
+      content: firstResult.raw_content,
+      contentType: 'text',
+      length: firstResult.raw_content.length,
+      siteName: new URL(url).hostname,
+      title: new URL(url).hostname,
+      url: firstResult.url || url,
+    } satisfies CrawlSuccessResult;
+  } catch (error) {
+    console.error(error);
+  }
+
+  return;
+};
diff --git a/src/server/services/search/impls/index.ts b/src/server/services/search/impls/index.ts
index 77607c98108c5..1bac6ce7f83c6 100644
--- a/src/server/services/search/impls/index.ts
+++ b/src/server/services/search/impls/index.ts
@@ -1,5 +1,7 @@
 import { Search1APIImpl } from './search1api';
 import { SearXNGImpl } from './searxng';
+import { TavilyImpl } from './tavily';
+
 import { SearchServiceImpl } from './type';
 
 /**
@@ -8,6 +10,7 @@ import { SearchServiceImpl } from './type';
 export enum SearchImplType {
   SearXNG = 'searxng',
   Search1API = 'search1api',
+  Tavily = 'tavily',
 }
 
 /**
@@ -21,6 +24,10 @@ export const createSearchServiceImpl = (
       return new SearXNGImpl();
     }
 
+    case SearchImplType.Tavily: {
+      return new TavilyImpl();
+    }
+
     default: {
       return new Search1APIImpl();
     }
diff --git a/src/server/services/search/impls/tavily/index.ts b/src/server/services/search/impls/tavily/index.ts
new file mode 100644
index 0000000000000..5419375a640c7
--- /dev/null
+++ b/src/server/services/search/impls/tavily/index.ts
@@ -0,0 +1,140 @@
+import { TRPCError } from '@trpc/server';
+import debug from 'debug';
+import urlJoin from 'url-join';
+
+import { SearchParams, UniformSearchResponse, UniformSearchResult } from '@/types/tool/search';
+
+import { SearchServiceImpl } from '../type';
+import { TavilyResponse } from './type';
+
+interface TavilyQueryParams {
+  chunks_per_source?: number;
+  days?: number;
+  exclude_domains?: string[];
+  include_answer?: boolean | string;
+  include_domains?: string[];
+  include_images?: boolean;
+  include_image_descriptions?: boolean;
+  include_raw_content?: boolean;
+  max_results?: number;
+  query: string;
+  search_depth?: string;
+  time_range?: string;
+  topic?: string;
+}
+
+const log = debug('lobe-search:Tavily');
+
+/**
+ * Tavily implementation of the search service
+ * Primarily used for web crawling
+ */
+export class TavilyImpl implements SearchServiceImpl {
+  private get apiKey(): string | undefined {
+    return process.env.TAVILY_API_KEY;
+  }
+
+  private get baseUrl(): string {
+    // Assuming the base URL is consistent with the crawl endpoint
+    return 'https://api.tavily.com';
+  }
+
+  async query(query: string, params: SearchParams = {}): Promise<UniformSearchResponse> {
+    log('Starting Tavily query with query: "%s", params: %o', query, params);
+    const endpoint = urlJoin(this.baseUrl, '/search');
+
+    const defaultQueryParams: TavilyQueryParams = {
+      include_answer: false,
+      include_images: false,
+      include_image_descriptions: true,
+      include_raw_content: false,
+      max_results: 15,
+      query,
+      search_depth: process.env.TAVILY_SEARCH_DEPTH || 'basic' // basic or advanced
+    };
+
+    let body: TavilyQueryParams = {
+      ...defaultQueryParams,
+      time_range:
+        params?.searchTimeRange && params.searchTimeRange !== 'anytime'
+          ? params.searchTimeRange
+          : undefined,
+      topic:
+        // Tavily 只支持 news 和 general 两种类型
+        params?.searchCategories?.filter(cat => ['news', 'general'].includes(cat))?.[0],
+    };
+
+    log('Constructed request body: %o', body);
+
+    let response: Response;
+    const startAt = Date.now();
+    let costTime = 0;
+    try {
+      log('Sending request to endpoint: %s', endpoint);
+      response = await fetch(endpoint, {
+        body: JSON.stringify(body),
+        headers: {
+          'Authorization': this.apiKey ? `Bearer ${this.apiKey}` : '',
+          'Content-Type': 'application/json',
+        },
+        method: 'POST',
+      });
+      log('Received response with status: %d', response.status);
+      costTime = Date.now() - startAt;
+    } catch (error) {
+      log.extend('error')('Tavily fetch error: %o', error);
+      throw new TRPCError({
+        cause: error,
+        code: 'SERVICE_UNAVAILABLE',
+        message: 'Failed to connect to Tavily.',
+      });
+    }
+
+    if (!response.ok) {
+      const errorBody = await response.text();
+      log.extend('error')(
+        `Tavily request failed with status ${response.status}: %s`,
+        errorBody.length > 200 ? `${errorBody.slice(0, 200)}...` : errorBody,
+      );
+      throw new TRPCError({
+        cause: errorBody,
+        code: 'SERVICE_UNAVAILABLE',
+        message: `Tavily request failed: ${response.statusText}`,
+      });
+    }
+
+    try {
+      const tavilyResponse = (await response.json()) as TavilyResponse;
+
+      log('Parsed Tavily response: %o', tavilyResponse);
+
+      const mappedResults = (tavilyResponse.results || []).map(
+        (result): UniformSearchResult => ({
+          category: body.topic || 'general', // Default category
+          content: result.content || '', // Prioritize content, fallback to snippet
+          engines: ['tavily'], // Use 'tavily' as the engine name
+          parsedUrl: result.url ? new URL(result.url).hostname : '', // Basic URL parsing
+          score: result.score || 0, // Default score to 0 if undefined
+          title: result.title || '',
+          url: result.url,
+        }),
+      );
+
+      log('Mapped %d results to SearchResult format', mappedResults.length);
+
+      return {
+        costTime,
+        query: query,
+        resultNumbers: mappedResults.length,
+        results: mappedResults,
+      };
+    } catch (error) {
+      log.extend('error')('Error parsing Tavily response: %o', error);
+      throw new TRPCError({
+        cause: error,
+        code: 'INTERNAL_SERVER_ERROR',
+        message: 'Failed to parse Tavily response.',
+      });
+    }
+  }
+}
diff --git a/src/server/services/search/impls/tavily/type.ts b/src/server/services/search/impls/tavily/type.ts
new file mode 100644
index 0000000000000..84e0009a6b495
--- /dev/null
+++ b/src/server/services/search/impls/tavily/type.ts
@@ -0,0 +1,36 @@
+export interface TavilySearchParameters {
+  chunks_per_source?: number;
+  days?: number;
+  exclude_domains?: string[];
+  include_answer?: boolean | string;
+  include_domains?: string[];
+  include_images?: boolean;
+  include_image_descriptions?: boolean;
+  include_raw_content?: boolean;
+  max_results?: number;
+  query: string;
+  search_depth?: string;
+  time_range?: string;
+  topic?: string;
+}
+
+interface TavilyImages {
+  description?: string;
+  url: string;
+}
+
+interface TavilyResults {
+  content?: string;
+  url: string;
+  raw_content?: string | null;
+  score?: number;
+  title?: string;
+}
+
+export interface TavilyResponse {
+  answer?: string;
+  images?: TavilyImages[];
+  query: string;
+  response_time: number;
+  results: TavilyResults[];
+}
