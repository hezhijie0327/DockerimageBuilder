diff --git a/src/server/services/search/impls/anspire/index.ts b/src/server/services/search/impls/anspire/index.ts
new file mode 100644
index 0000000000000..7745ee0973112
--- /dev/null
+++ b/src/server/services/search/impls/anspire/index.ts
@@ -0,0 +1,132 @@
+import { TRPCError } from '@trpc/server';
+import debug from 'debug';
+import urlJoin from 'url-join';
+
+import { SearchParams, UniformSearchResponse, UniformSearchResult } from '@/types/tool/search';
+
+import { SearchServiceImpl } from '../type';
+import { AnspireSearchParameters, AnspireResponse } from './type';
+
+const log = debug('lobe-search:Anspire');
+
+/**
+ * Anspire implementation of the search service
+ * Primarily used for web crawling
+ */
+export class AnspireImpl implements SearchServiceImpl {
+  private get apiKey(): string | undefined {
+    return process.env.ANSPIRE_API_KEY;
+  }
+
+  private get baseUrl(): string {
+    // Assuming the base URL is consistent with the crawl endpoint
+    return 'https://plugin.anspire.cn/api';
+  }
+
+  async query(query: string, params: SearchParams = {}): Promise<UniformSearchResponse> {
+    log('Starting Anspire query with query: "%s", params: %o', query, params);
+    const endpoint = urlJoin(this.baseUrl, '/ntsearch/search');
+
+    const defaultQueryParams: AnspireSearchParameters = {
+      mode: 0,
+      query,
+      top_k: 20,
+    };
+
+    let body: AnspireSearchParameters = {
+      ...defaultQueryParams,
+      ...(params?.searchTimeRange && params.searchTimeRange !== 'anytime'
+        ? (() => {
+            const now = Date.now();
+            const days = { day: 1, month: 30, week: 7, year: 365 }[params.searchTimeRange!];
+
+            if (days === undefined) return {};
+
+            return {
+              FromTime: new Date(now - days * 86_400 * 1000).toISOString().slice(0, 19).replace('T', ' '),
+              ToTime: new Date(now).toISOString().slice(0, 19).replace('T', ' '),
+            };
+          })()
+        : {}),
+    };
+
+    log('Constructed request body: %o', body);
+
+    const searchParams = new URLSearchParams();
+    for (const [key, value] of Object.entries(body)) {
+      searchParams.append(key, String(value));
+    }
+
+    let response: Response;
+    const startAt = Date.now();
+    let costTime = 0;
+    try {
+      log('Sending request to endpoint: %s', endpoint);
+      response = await fetch(`${endpoint}?${searchParams.toString()}`, {
+        headers: {
+          'Accept': '*/*',
+          'Authorization': this.apiKey ? `Bearer ${this.apiKey}` : '',
+          'Connection': 'keep-alive ',
+          'Content-Type': 'application/json',
+        },
+        method: 'GET',
+      });
+      log('Received response with status: %d', response.status);
+      costTime = Date.now() - startAt;
+    } catch (error) {
+      log.extend('error')('Anspire fetch error: %o', error);
+      throw new TRPCError({
+        cause: error,
+        code: 'SERVICE_UNAVAILABLE',
+        message: 'Failed to connect to Anspire.',
+      });
+    }
+
+    if (!response.ok) {
+      const errorBody = await response.text();
+      log.extend('error')(
+        `Anspire request failed with status ${response.status}: %s`,
+        errorBody.length > 200 ? `${errorBody.slice(0, 200)}...` : errorBody,
+      );
+      throw new TRPCError({
+        cause: errorBody,
+        code: 'SERVICE_UNAVAILABLE',
+        message: `Anspire request failed: ${response.statusText}`,
+      });
+    }
+
+    try {
+      const anspireResponse = (await response.json()) as AnspireResponse;
+
+      log('Parsed Anspire response: %o', anspireResponse);
+
+      const mappedResults = (anspireResponse.results || []).map(
+        (result): UniformSearchResult => ({
+          category: 'general', // Default category
+          content: result.content || '', // Prioritize content
+          engines: ['anspire'], // Use 'anspire' as the engine name
+          parsedUrl: result.url ? new URL(result.url).hostname : '', // Basic URL parsing
+          score: result.score || 0, // Default score to 0 if undefined
+          title: result.title || '',
+          url: result.url,
+        }),
+      );
+
+      log('Mapped %d results to SearchResult format', mappedResults.length);
+
+      return {
+        costTime,
+        query: query,
+        resultNumbers: mappedResults.length,
+        results: mappedResults,
+      };
+    } catch (error) {
+      log.extend('error')('Error parsing Anspire response: %o', error);
+      throw new TRPCError({
+        cause: error,
+        code: 'INTERNAL_SERVER_ERROR',
+        message: 'Failed to parse Anspire response.',
+      });
+    }
+  }
+}
diff --git a/src/server/services/search/impls/anspire/type.ts b/src/server/services/search/impls/anspire/type.ts
new file mode 100644
index 0000000000000..e01fe6896b06a
--- /dev/null
+++ b/src/server/services/search/impls/anspire/type.ts
@@ -0,0 +1,21 @@
+export interface AnspireSearchParameters {
+  FromTime?: string;
+  Insite?: string;
+  mode?: number;
+  query: string;
+  top_k?: number;
+  ToTime?: string;
+}
+
+interface AnspireResults {
+  content?: string;
+  score?: number;
+  title: string;
+  url: string;
+}
+
+export interface AnspireResponse {
+  query?: string;
+  results?: AnspireResults[];
+  Uuid?: string;
+}
diff --git a/src/server/services/search/impls/brave/index.ts b/src/server/services/search/impls/brave/index.ts
new file mode 100644
index 0000000000000..bb3fc590b133e
--- /dev/null
+++ b/src/server/services/search/impls/brave/index.ts
@@ -0,0 +1,129 @@
+import { TRPCError } from '@trpc/server';
+import debug from 'debug';
+import urlJoin from 'url-join';
+
+import { SearchParams, UniformSearchResponse, UniformSearchResult } from '@/types/tool/search';
+
+import { SearchServiceImpl } from '../type';
+import { BraveSearchParameters, BraveResponse } from './type';
+
+const log = debug('lobe-search:Brave');
+
+const timeRangeMapping = {
+  day: 'pd',
+  month: 'pm',
+  week: 'pw',
+  year: 'py',
+};
+
+/**
+ * Brave implementation of the search service
+ * Primarily used for web crawling
+ */
+export class BraveImpl implements SearchServiceImpl {
+  private get apiKey(): string | undefined {
+    return process.env.BRAVE_API_KEY;
+  }
+
+  private get baseUrl(): string {
+    // Assuming the base URL is consistent with the crawl endpoint
+    return 'https://api.search.brave.com/res/v1';
+  }
+
+  async query(query: string, params: SearchParams = {}): Promise<UniformSearchResponse> {
+    log('Starting Brave query with query: "%s", params: %o', query, params);
+    const endpoint = urlJoin(this.baseUrl, '/web/search');
+
+    const defaultQueryParams: BraveSearchParameters = {
+      count: 15,
+      q: query,
+      result_filter: 'web',
+    };
+
+    let body: BraveSearchParameters = {
+      ...defaultQueryParams,
+      freshness:
+        params?.searchTimeRange && params.searchTimeRange !== 'anytime'
+          ? timeRangeMapping[params.searchTimeRange as keyof typeof timeRangeMapping] ?? undefined
+          : undefined,
+    };
+
+    log('Constructed request body: %o', body);
+
+    const searchParams = new URLSearchParams();
+    for (const [key, value] of Object.entries(body)) {
+      searchParams.append(key, String(value));
+    }
+
+    let response: Response;
+    const startAt = Date.now();
+    let costTime = 0;
+    try {
+      log('Sending request to endpoint: %s', endpoint);
+      response = await fetch(`${endpoint}?${searchParams.toString()}`, {
+        headers: {
+          'Accept': 'application/json',
+          'Accept-Encoding': 'gzip',
+          'X-Subscription-Token': this.apiKey ? this.apiKey : '',
+        },
+        method: 'GET',
+      });
+      log('Received response with status: %d', response.status);
+      costTime = Date.now() - startAt;
+    } catch (error) {
+      log.extend('error')('Brave fetch error: %o', error);
+      throw new TRPCError({
+        cause: error,
+        code: 'SERVICE_UNAVAILABLE',
+        message: 'Failed to connect to Brave.',
+      });
+    }
+
+    if (!response.ok) {
+      const errorBody = await response.text();
+      log.extend('error')(
+        `Brave request failed with status ${response.status}: %s`,
+        errorBody.length > 200 ? `${errorBody.slice(0, 200)}...` : errorBody,
+      );
+      throw new TRPCError({
+        cause: errorBody,
+        code: 'SERVICE_UNAVAILABLE',
+        message: `Brave request failed: ${response.statusText}`,
+      });
+    }
+
+    try {
+      const braveResponse = (await response.json()) as BraveResponse;
+
+      log('Parsed Brave response: %o', braveResponse);
+
+      const mappedResults = (braveResponse.web.results || []).map(
+        (result): UniformSearchResult => ({
+          category: 'general', // Default category
+          content: result.description || '', // Prioritize content
+          engines: ['brave'], // Use 'brave' as the engine name
+          parsedUrl: result.url ? new URL(result.url).hostname : '', // Basic URL parsing
+          score: 1, // Default score to 1
+          title: result.title || '',
+          url: result.url,
+        }),
+      );
+
+      log('Mapped %d results to SearchResult format', mappedResults.length);
+
+      return {
+        costTime,
+        query: query,
+        resultNumbers: mappedResults.length,
+        results: mappedResults,
+      };
+    } catch (error) {
+      log.extend('error')('Error parsing Brave response: %o', error);
+      throw new TRPCError({
+        cause: error,
+        code: 'INTERNAL_SERVER_ERROR',
+        message: 'Failed to parse Brave response.',
+      });
+    }
+  }
+}
diff --git a/src/server/services/search/impls/brave/type.ts b/src/server/services/search/impls/brave/type.ts
new file mode 100644
index 0000000000000..74a8251d1faf2
--- /dev/null
+++ b/src/server/services/search/impls/brave/type.ts
@@ -0,0 +1,58 @@
+export interface BraveSearchParameters {
+  count?: number;
+  country?: string;
+  enable_rich_callback?: boolean;
+  extra_snippets?: boolean;
+  freshness?: string;
+  goggles?: string[];
+  goggles_id?: string;
+  offset?: number;
+  q: string;
+  result_filter?: string;
+  safesearch?: string;
+  search_lang?: string;
+  spellcheck?: boolean;
+  summary?: boolean;
+  text_decorations?: boolean;
+  ui_lang?: string;
+  units?: string;
+}
+
+interface BraveResults {
+  age?: string;
+  description: string;
+  family_friendly?: boolean;
+  is_live?: boolean;
+  is_source_both?: boolean;
+  is_source_local?: boolean;
+  language?: string;
+  meta_url?: any;
+  page_age?: string;
+  profile?: any;
+  subtype?: string;
+  thumbnail?: any;
+  title: string;
+  type: string;
+  url: string;
+  video?: any;
+}
+
+interface BraveVideos {
+  mutated_by_goggles?: boolean;
+  results: BraveResults[];
+  type: string;
+}
+
+interface BraveWeb {
+  family_friendly?: boolean;
+  results: BraveResults[];
+  type: string;
+}
+
+export interface BraveResponse {
+  mixed: any;
+  query?: any;
+  type: string;
+  videos?: BraveVideos;
+  web: BraveWeb;
+}
diff --git a/src/server/services/search/impls/google/index.ts b/src/server/services/search/impls/google/index.ts
new file mode 100644
index 0000000000000..8ba9cb8638bfe
--- /dev/null
+++ b/src/server/services/search/impls/google/index.ts
@@ -0,0 +1,129 @@
+import { TRPCError } from '@trpc/server';
+import debug from 'debug';
+import urlJoin from 'url-join';
+
+import { SearchParams, UniformSearchResponse, UniformSearchResult } from '@/types/tool/search';
+
+import { SearchServiceImpl } from '../type';
+import { GoogleSearchParameters, GoogleResponse } from './type';
+
+const log = debug('lobe-search:Google');
+
+const timeRangeMapping = {
+  day: 'd1',
+  month: 'm1',
+  week: 'w1',
+  year: 'y1',
+};
+
+/**
+ * Google implementation of the search service
+ * Primarily used for web crawling
+ */
+export class GoogleImpl implements SearchServiceImpl {
+  private get apiKey(): string | undefined {
+    return process.env.GOOGLE_PSE_API_KEY;
+  }
+
+  private get engineId(): string | undefined {
+    return process.env.GOOGLE_PSE_ENGINE_ID;
+  }
+
+  private get baseUrl(): string {
+    // Assuming the base URL is consistent with the crawl endpoint
+    return 'https://www.googleapis.com';
+  }
+
+  async query(query: string, params: SearchParams = {}): Promise<UniformSearchResponse> {
+    log('Starting Google query with query: "%s", params: %o', query, params);
+    const endpoint = urlJoin(this.baseUrl, '/customsearch/v1');
+
+    const defaultQueryParams: GoogleSearchParameters = {
+      cx: this.engineId || '',
+      key: this.apiKey || '',
+      num: 10,
+      q: query,
+    };
+
+    let body: GoogleSearchParameters = {
+      ...defaultQueryParams,
+      dateRestrict:
+        params?.searchTimeRange && params.searchTimeRange !== 'anytime'
+          ? timeRangeMapping[params.searchTimeRange as keyof typeof timeRangeMapping] ?? undefined
+          : undefined,
+    };
+
+    log('Constructed request body: %o', body);
+
+    const searchParams = new URLSearchParams();
+    for (const [key, value] of Object.entries(body)) {
+      searchParams.append(key, String(value));
+    }
+
+    let response: Response;
+    const startAt = Date.now();
+    let costTime = 0;
+    try {
+      log('Sending request to endpoint: %s', endpoint);
+      response = await fetch(`${endpoint}?${searchParams.toString()}`, {
+        method: 'GET',
+      });
+      log('Received response with status: %d', response.status);
+      costTime = Date.now() - startAt;
+    } catch (error) {
+      log.extend('error')('Google fetch error: %o', error);
+      throw new TRPCError({
+        cause: error,
+        code: 'SERVICE_UNAVAILABLE',
+        message: 'Failed to connect to Google.',
+      });
+    }
+
+    if (!response.ok) {
+      const errorBody = await response.text();
+      log.extend('error')(
+        `Google request failed with status ${response.status}: %s`,
+        errorBody.length > 200 ? `${errorBody.slice(0, 200)}...` : errorBody,
+      );
+      throw new TRPCError({
+        cause: errorBody,
+        code: 'SERVICE_UNAVAILABLE',
+        message: `Google request failed: ${response.statusText}`,
+      });
+    }
+
+    try {
+      const googleResponse = (await response.json()) as GoogleResponse;
+
+      log('Parsed Google response: %o', googleResponse);
+
+      const mappedResults = (googleResponse.items || []).map(
+        (result): UniformSearchResult => ({
+          category: 'general', // Default category
+          content: result.snippet || '', // Prioritize content
+          engines: ['google'], // Use 'google' as the engine name
+          parsedUrl: result.link ? new URL(result.link).hostname : '', // Basic URL parsing
+          score: 1, // Default score to 1
+          title: result.title || '',
+          url: result.link,
+        }),
+      );
+
+      log('Mapped %d results to SearchResult format', mappedResults.length);
+
+      return {
+        costTime,
+        query: query,
+        resultNumbers: mappedResults.length,
+        results: mappedResults,
+      };
+    } catch (error) {
+      log.extend('error')('Error parsing Google response: %o', error);
+      throw new TRPCError({
+        cause: error,
+        code: 'INTERNAL_SERVER_ERROR',
+        message: 'Failed to parse Google response.',
+      });
+    }
+  }
+}
diff --git a/src/server/services/search/impls/google/type.ts b/src/server/services/search/impls/google/type.ts
new file mode 100644
index 0000000000000..4600d604b8e24
--- /dev/null
+++ b/src/server/services/search/impls/google/type.ts
@@ -0,0 +1,53 @@
+export interface GoogleSearchParameters {
+  c2coff?: number;
+  cx: string;
+  dateRestrict?: string;
+  exactTerms?: string;
+  excludeTerms?: string;
+  fileType?: string;
+  filter?: string;
+  gl?: string;
+  highRange?: string;
+  hl?: string;
+  hq?: string;
+  imgColorType?: string;
+  imgDominantColor?: string;
+  imgSize?: string;
+  imgType?: string;
+  key: string;
+  linkSite?: string;
+  lowRange?: string;
+  lr?: string;
+  num?: number;
+  orTerms?: string;
+  q: string;
+  rights?: string;
+  safe?: string;
+  searchType?: string;
+  siteSearch?: string;
+  siteSearchFilter?: string;
+  sort?: string;
+  start?: string;
+}
+
+interface GoogleItems {
+  displayLink?: string;
+  formattedUrl?: string;
+  htmlFormattedUrl?: string;
+  htmlSnippet?: string;
+  htmlTitle?: string;
+  kind?: string;
+  link: string;
+  pagemap?: any;
+  snippet: string;
+  title: string;
+}
+
+export interface GoogleResponse {
+  context?: any;
+  items: GoogleItems[];
+  kind?: string;
+  queries?: any;
+  searchInformation?: any;
+  url?: any;
+}
diff --git a/src/server/services/search/impls/index.ts b/src/server/services/search/impls/index.ts
index a71a38507d519..334083ca40aa6 100644
--- a/src/server/services/search/impls/index.ts
+++ b/src/server/services/search/impls/index.ts
@@ -1,7 +1,11 @@
+import { AnspireImpl } from './anspire';
 import { BochaImpl } from './bocha';
+import { BraveImpl } from './brave';
 import { ExaImpl } from './exa';
 import { FirecrawlImpl } from './firecrawl';
+import { GoogleImpl } from './google';
 import { JinaImpl } from './jina';
+import { KagiImpl } from './kagi';
 import { Search1APIImpl } from './search1api';
 import { SearXNGImpl } from './searxng';
 import { TavilyImpl } from './tavily';
@@ -12,10 +16,14 @@ import { SearchServiceImpl } from './type';
  * Available search service implementations
  */
 export enum SearchImplType {
+  Anspire = 'anspire',
   Bocha = 'bocha',
+  Brave = 'brave',
   Exa = 'exa',
   Firecrawl = 'firecrawl',
+  Google = 'google',
   Jina = 'jina',
+  Kagi = 'kagi',
   SearXNG = 'searxng',
   Search1API = 'search1api',
   Tavily = 'tavily',
@@ -28,10 +36,18 @@ export const createSearchServiceImpl = (
   type: SearchImplType = SearchImplType.SearXNG,
 ): SearchServiceImpl => {
   switch (type) {
+    case SearchImplType.Anspire: {
+      return new AnspireImpl();
+    }
+
     case SearchImplType.Bocha: {
       return new BochaImpl();
     }
 
+    case SearchImplType.Brave: {
+      return new BraveImpl();
+    }
+
     case SearchImplType.Exa: {
       return new ExaImpl();
     }
@@ -40,10 +56,18 @@ export const createSearchServiceImpl = (
       return new FirecrawlImpl();
     }
 
+    case SearchImplType.Google: {
+      return new GoogleImpl();
+    }
+
     case SearchImplType.Jina: {
       return new JinaImpl();
     }
 
+    case SearchImplType.Kagi: {
+      return new KagiImpl();
+    }
+
     case SearchImplType.SearXNG: {
       return new SearXNGImpl();
     }
diff --git a/src/server/services/search/impls/kagi/index.ts b/src/server/services/search/impls/kagi/index.ts
new file mode 100644
index 0000000000000..d41221cef409c
--- /dev/null
+++ b/src/server/services/search/impls/kagi/index.ts
@@ -0,0 +1,111 @@
+import { TRPCError } from '@trpc/server';
+import debug from 'debug';
+import urlJoin from 'url-join';
+
+import { SearchParams, UniformSearchResponse, UniformSearchResult } from '@/types/tool/search';
+
+import { SearchServiceImpl } from '../type';
+import { KagiSearchParameters, KagiResponse } from './type';
+
+const log = debug('lobe-search:Kagi');
+
+/**
+ * Kagi implementation of the search service
+ * Primarily used for web crawling
+ */
+export class KagiImpl implements SearchServiceImpl {
+  private get apiKey(): string | undefined {
+    return process.env.KAGI_API_KEY;
+  }
+
+  private get baseUrl(): string {
+    // Assuming the base URL is consistent with the crawl endpoint
+    return 'https://kagi.com/api/v0';
+  }
+
+  async query(query: string, params: SearchParams = {}): Promise<UniformSearchResponse> {
+    log('Starting Kagi query with query: "%s", params: %o', query, params);
+    const endpoint = urlJoin(this.baseUrl, '/search');
+
+    const body: KagiSearchParameters = {
+      limit: 15,
+      q: query,
+    };
+
+    log('Constructed request body: %o', body);
+
+    const searchParams = new URLSearchParams();
+    for (const [key, value] of Object.entries(body)) {
+      searchParams.append(key, String(value));
+    }
+
+    let response: Response;
+    const startAt = Date.now();
+    let costTime = 0;
+    try {
+      log('Sending request to endpoint: %s', endpoint);
+      response = await fetch(`${endpoint}?${searchParams.toString()}`, {
+        headers: {
+          'Authorization': this.apiKey ? `Bot ${this.apiKey}` : '',
+        },
+        method: 'GET',
+      });
+      log('Received response with status: %d', response.status);
+      costTime = Date.now() - startAt;
+    } catch (error) {
+      log.extend('error')('Kagi fetch error: %o', error);
+      throw new TRPCError({
+        cause: error,
+        code: 'SERVICE_UNAVAILABLE',
+        message: 'Failed to connect to Kagi.',
+      });
+    }
+
+    if (!response.ok) {
+      const errorBody = await response.text();
+      log.extend('error')(
+        `Kagi request failed with status ${response.status}: %s`,
+        errorBody.length > 200 ? `${errorBody.slice(0, 200)}...` : errorBody,
+      );
+      throw new TRPCError({
+        cause: errorBody,
+        code: 'SERVICE_UNAVAILABLE',
+        message: `Kagi request failed: ${response.statusText}`,
+      });
+    }
+
+    try {
+      const kagiResponse = (await response.json()) as KagiResponse;
+
+      log('Parsed Kagi response: %o', kagiResponse);
+
+      const mappedResults = (kagiResponse.data || []).map(
+        (result): UniformSearchResult => ({
+          category: 'general', // Default category
+          content: result.snippet || '', // Prioritize content
+          engines: ['kagi'], // Use 'kagi' as the engine name
+          parsedUrl: result.url ? new URL(result.url).hostname : '', // Basic URL parsing
+          score: 1, // Default score to 1
+          title: result.title || '',
+          url: result.url,
+        }),
+      );
+
+      log('Mapped %d results to SearchResult format', mappedResults.length);
+
+      return {
+        costTime,
+        query: query,
+        resultNumbers: mappedResults.length,
+        results: mappedResults,
+      };
+    } catch (error) {
+      log.extend('error')('Error parsing Kagi response: %o', error);
+      throw new TRPCError({
+        cause: error,
+        code: 'INTERNAL_SERVER_ERROR',
+        message: 'Failed to parse Kagi response.',
+      });
+    }
+  }
+}
diff --git a/src/server/services/search/impls/kagi/type.ts b/src/server/services/search/impls/kagi/type.ts
new file mode 100644
index 0000000000000..c6275b509f849
--- /dev/null
+++ b/src/server/services/search/impls/kagi/type.ts
@@ -0,0 +1,24 @@
+export interface KagiSearchParameters {
+  limit?: number;
+  q: string;
+}
+
+interface KagiThumbnail {
+  height?: number | null;
+  url: string;
+  width?: number | null;
+}
+
+interface KagiData {
+  published?: number;
+  snippet?: string;
+  t: number;
+  thumbnail?: KagiThumbnail;
+  title: string;
+  url: string;
+}
+
+export interface KagiResponse {
+  data: KagiData[];
+  meta?: any;
+}
