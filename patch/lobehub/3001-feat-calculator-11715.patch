diff --git a/package.json b/package.json
index 428f8d89e4c00..8c2d2e51b61eb 100644
--- a/package.json
+++ b/package.json
@@ -166,6 +166,7 @@
     "@lobechat/agent-runtime": "workspace:*",
     "@lobechat/builtin-agents": "workspace:*",
     "@lobechat/builtin-tool-agent-builder": "workspace:*",
+    "@lobechat/builtin-tool-calculator": "workspace:*",
     "@lobechat/builtin-tool-cloud-sandbox": "workspace:*",
     "@lobechat/builtin-tool-group-agent-builder": "workspace:*",
     "@lobechat/builtin-tool-group-management": "workspace:*",
diff --git a/packages/builtin-tool-calculator/package.json b/packages/builtin-tool-calculator/package.json
new file mode 100644
index 0000000000000..64ea6ea2f7ce7
--- /dev/null
+++ b/packages/builtin-tool-calculator/package.json
@@ -0,0 +1,25 @@
+{
+  "name": "@lobechat/builtin-tool-calculator",
+  "version": "1.0.0",
+  "private": true,
+  "exports": {
+    ".": "./src/index.ts",
+    "./client": "./src/client/index.ts",
+    "./executor": "./src/executor/index.ts"
+  },
+  "main": "./src/index.ts",
+  "dependencies": {
+    "@lobechat/prompts": "workspace:*",
+    "mathjs": "^12.4.3"
+  },
+  "devDependencies": {
+    "@lobechat/types": "workspace:*"
+  },
+  "peerDependencies": {
+    "@lobehub/ui": "^4",
+    "antd-style": "*",
+    "lucide-react": "*",
+    "react": "*",
+    "react-i18next": "*"
+  }
+}
diff --git a/packages/builtin-tool-calculator/src/calculate.test.ts b/packages/builtin-tool-calculator/src/calculate.test.ts
new file mode 100644
index 0000000000000..19f195f7de9df
--- /dev/null
+++ b/packages/builtin-tool-calculator/src/calculate.test.ts
@@ -0,0 +1,494 @@
+import { describe, expect, it } from 'vitest';
+
+import { calculatorExecutor } from '../src/executor';
+
+describe('Unit Conversion', () => {
+  it('should handle temperature conversion with mathjs syntax', async () => {
+    const result = await calculatorExecutor.calculate({ expression: '25 degC to degF' });
+    expect(result.success).toBe(true);
+    expect(parseFloat(result.content || '0')).toBeCloseTo(77, 0);
+  });
+
+  it('should handle various temperature formats', async () => {
+    const fahrenheit = await calculatorExecutor.calculate({ expression: '100 degC to degF' });
+    expect(fahrenheit.success).toBe(true);
+    expect(parseFloat(fahrenheit.content || '0')).toBeCloseTo(212, 0);
+
+    const celsius = await calculatorExecutor.calculate({ expression: '32 degF to degC' });
+    expect(celsius.success).toBe(true);
+    expect(parseFloat(celsius.content || '0')).toBeCloseTo(0, 0);
+  });
+
+  it('should handle length conversions with mathjs syntax', async () => {
+    const result = await calculatorExecutor.calculate({ expression: '5 cm to inch' });
+    expect(result.success).toBe(true);
+    expect(parseFloat(result.content || '0')).toBeCloseTo(1.9685, 3);
+  });
+
+  it('should handle weight conversions', async () => {
+    const result = await calculatorExecutor.calculate({ expression: '1 kg to lb' });
+    expect(result.success).toBe(true);
+    expect(parseFloat(result.content || '0')).toBeCloseTo(2.2046, 3);
+  });
+
+  it('should handle speed conversions', async () => {
+    const result = await calculatorExecutor.calculate({ expression: '100 km/h to mph' });
+    // Note: This might fail depending on mathjs unit support
+    console.log('Speed result:', result.content, result.success);
+    if (result.success) {
+      expect(parseFloat(result.content || '0')).toBeCloseTo(62.137, 2);
+    } else {
+      // Some unit combinations might not be supported
+      expect(result.success).toBe(false);
+    }
+  });
+
+  it('should handle invalid temperature syntax gracefully', async () => {
+    const result = await calculatorExecutor.calculate({ expression: '25 Â°C to Â°F' });
+    // This might fail due to Unicode degree symbol
+    console.log('Unicode result:', result.content, result.success);
+  });
+});
+
+describe('Math Constants', () => {
+  it('should handle PI constants', async () => {
+    const pi = await calculatorExecutor.calculate({ expression: 'pi' });
+    expect(pi.success).toBe(true);
+    expect(parseFloat(pi.content || '0')).toBeCloseTo(3.14159, 5);
+  });
+
+  it('should handle uppercase PI', async () => {
+    const PI = await calculatorExecutor.calculate({ expression: 'PI' });
+    expect(PI.success).toBe(true);
+    expect(parseFloat(PI.content || '0')).toBeCloseTo(3.14159, 5);
+  });
+
+  it('should handle PI in expressions', async () => {
+    const result = await calculatorExecutor.calculate({ expression: '2 * pi' });
+    expect(result.success).toBe(true);
+    expect(parseFloat(result.content || '0')).toBeCloseTo(6.28318, 4);
+  });
+
+  it('should handle PI in trigonometric functions', async () => {
+    const result = await calculatorExecutor.calculate({ expression: 'sin(pi/2)' });
+    expect(result.success).toBe(true);
+    expect(parseFloat(result.content || '0')).toBeCloseTo(1, 5);
+  });
+
+  it('should handle PI in evaluateExpression', async () => {
+    const result = await calculatorExecutor.evaluateExpression({
+      expression: 'x * pi',
+      variables: { x: 3 },
+    });
+    expect(result.success).toBe(true);
+    expect(parseFloat(result.content || '0')).toBeCloseTo(9.42477, 4);
+  });
+
+  it('should handle other constants like E', async () => {
+    const e = await calculatorExecutor.calculate({ expression: 'e' });
+    expect(e.success).toBe(true);
+    expect(parseFloat(e.content || '0')).toBeCloseTo(2.71828, 5);
+  });
+
+  it('should handle constants in scientific notation', async () => {
+    const result = await calculatorExecutor.calculate({ expression: 'pi * 1e3' });
+    expect(result.success).toBe(true);
+    expect(parseFloat(result.content || '0')).toBeCloseTo(3141.59, 2);
+  });
+});
+
+describe('Calculator Base Conversion', () => {
+  it('should convert binary to decimal', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: '1010',
+      fromBase: 2,
+      toBase: 10,
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('10');
+    expect(result.state?.decimalValue).toBe(10);
+  });
+
+  it('should convert decimal to binary', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: '255',
+      fromBase: 10,
+      toBase: 2,
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('11111111');
+    expect(result.state?.decimalValue).toBe(255);
+  });
+
+  it('should convert hexadecimal to octal', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: 'FF',
+      fromBase: 16,
+      toBase: 8,
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('377');
+    expect(result.state?.decimalValue).toBe(255);
+  });
+
+  it('should convert octal to hexadecimal', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: '77',
+      fromBase: 8,
+      toBase: 16,
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('3F');
+    expect(result.state?.decimalValue).toBe(63);
+  });
+
+  it('should handle hexadecimal input', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: 'FF',
+      fromBase: 16,
+      toBase: 10,
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('255');
+    expect(result.state?.decimalValue).toBe(255);
+  });
+
+  it('should handle invalid numbers', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: '2AB',
+      fromBase: 2,
+      toBase: 10,
+    });
+
+    expect(result.success).toBe(false);
+    expect(result.error?.type).toBe('ConversionError');
+  });
+
+  it('should support bases 2-36 with numeric input', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: 'Z',
+      fromBase: 36,
+      toBase: 10,
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('35');
+    expect(result.state?.decimalValue).toBe(35);
+  });
+
+  it('should convert decimal to base 32', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: '1000',
+      fromBase: 10,
+      toBase: 32,
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('V8');
+    expect(result.state?.decimalValue).toBe(1000);
+  });
+
+  it('should handle invalid base numbers', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: '123',
+      fromBase: 1,
+      toBase: 10,
+    });
+
+    expect(result.success).toBe(false);
+    expect(result.error?.type).toBe('ConversionError');
+  });
+
+  it('should handle invalid base 37', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: '123',
+      fromBase: 10,
+      toBase: 37,
+    });
+
+    expect(result.success).toBe(false);
+    expect(result.error?.type).toBe('ConversionError');
+  });
+
+  it('should validate digit characters for base', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: 'G',
+      fromBase: 16,
+      toBase: 10,
+    });
+
+    expect(result.success).toBe(false);
+    expect(result.error?.type).toBe('ConversionError');
+  });
+});
+
+describe('Calculator Core Functions', () => {
+  describe('calculate', () => {
+    it('should handle basic arithmetic', async () => {
+      const result = await calculatorExecutor.calculate({
+        expression: '2 + 3 * 4',
+      });
+
+      expect(result.success).toBe(true);
+      expect(result.content).toBe('14');
+      expect(result.state?.result).toBe('14');
+    });
+
+    it('should handle unit conversions (cm to inch)', async () => {
+      const result = await calculatorExecutor.calculate({
+        expression: '5 cm to inch',
+      });
+
+      expect(result.success).toBe(true);
+      expect(result.content).toBe('1.968503937 inch');
+    });
+
+    it('should handle unit conversions (kg to lb)', async () => {
+      const result = await calculatorExecutor.calculate({
+        expression: '1 kg to lb',
+      });
+
+      expect(result.success).toBe(true);
+      expect(parseFloat(result.content || '0')).toBeCloseTo(2.20462, 5);
+    });
+
+    it('should handle scientific functions', async () => {
+      const result = await calculatorExecutor.calculate({
+        expression: 'sin(30 deg)',
+      });
+
+      expect(result.success).toBe(true);
+      expect(parseFloat(result.content || '0')).toBeCloseTo(0.5, 5);
+    });
+
+    it('should handle matrix operations', async () => {
+      const result = await calculatorExecutor.calculate({
+        expression: 'det([[1,2],[3,4]])',
+      });
+
+      expect(result.success).toBe(true);
+      expect(result.content).toBe('-2');
+    });
+
+    it('should handle complex numbers', async () => {
+      const result = await calculatorExecutor.calculate({
+        expression: 'sqrt(-1)',
+      });
+
+      expect(result.success).toBe(true);
+      expect(result.content).toBe('i');
+    });
+
+    it('should handle precision formatting', async () => {
+      const result = await calculatorExecutor.calculate({
+        expression: '10 / 3',
+        precision: 2,
+      });
+
+      expect(result.success).toBe(true);
+      expect(result.content).toBe('3.33');
+    });
+
+    it('should handle zero precision (default)', async () => {
+      const result = await calculatorExecutor.calculate({
+        expression: '10 / 3',
+        precision: 0,
+      });
+
+      expect(result.success).toBe(true);
+      expect(result.content).toBe('3');
+    });
+
+    it('should handle undefined expression', async () => {
+      const result = await calculatorExecutor.calculate({
+        expression: 'invalid_syntax_*(',
+      });
+
+      expect(result.success).toBe(false);
+      expect(result.error?.type).toBe('CalculationError');
+    });
+  });
+
+  describe('evaluateExpression', () => {
+    it('should handle variable substitution', async () => {
+      const result = await calculatorExecutor.evaluateExpression({
+        expression: 'x^2 + 2*x + 1',
+        variables: { x: 5 },
+      });
+
+      expect(result.success).toBe(true);
+      expect(result.content).toBe('36');
+      expect(result.state?.result).toBe('36');
+      expect(result.state?.variables).toEqual({ x: 5 });
+    });
+
+    it('should handle multiple variables', async () => {
+      const result = await calculatorExecutor.evaluateExpression({
+        expression: 'a*x + b',
+        variables: { a: 2, x: 3, b: 1 },
+      });
+
+      expect(result.success).toBe(true);
+      expect(result.content).toBe('7');
+    });
+
+    it('should handle no variables', async () => {
+      const result = await calculatorExecutor.evaluateExpression({
+        expression: '2 + 2',
+      });
+
+      expect(result.success).toBe(true);
+      expect(result.content).toBe('4');
+    });
+
+    it('should handle missing variables gracefully', async () => {
+      const result = await calculatorExecutor.evaluateExpression({
+        expression: 'x + y',
+        variables: { x: 1 }, // y is missing
+      });
+
+      expect(result.success).toBe(false);
+      expect(result.error?.type).toBe('CalculationError');
+    });
+
+    it('should handle complex expressions with variables', async () => {
+      const result = await calculatorExecutor.evaluateExpression({
+        expression: 'sin(x) * cos(y)',
+        variables: { x: 1.5708, y: 0 }, // Approximate pi/2
+      });
+
+      expect(result.success).toBe(true);
+      expect(parseFloat(result.content || '0')).toBeCloseTo(1, 5);
+    });
+  });
+
+  describe('convertBase', () => {
+    it('should handle number input in base conversion', async () => {
+      const result = await calculatorExecutor.convertBase({
+        number: 255,
+        fromBase: 10,
+        toBase: 2,
+      });
+
+      expect(result.success).toBe(true);
+      expect(result.content).toBe('11111111');
+    });
+
+    it('should handle string input in base conversion', async () => {
+      const result = await calculatorExecutor.convertBase({
+        number: '255',
+        fromBase: 10,
+        toBase: 2,
+      });
+
+      expect(result.success).toBe(true);
+      expect(result.content).toBe('11111111');
+    });
+
+    it('should handle zero in base conversion', async () => {
+      const result = await calculatorExecutor.convertBase({
+        number: '0',
+        fromBase: 10,
+        toBase: 16,
+      });
+
+      expect(result.success).toBe(true);
+      expect(result.content).toBe('0');
+    });
+
+    it('should handle large numbers', async () => {
+      const result = await calculatorExecutor.convertBase({
+        number: '4294967295',
+        fromBase: 10,
+        toBase: 16,
+      });
+
+      expect(result.success).toBe(true);
+      expect(result.content).toBe('FFFFFFFF');
+    });
+
+    it('should handle base 36 conversion', async () => {
+      const result = await calculatorExecutor.convertBase({
+        number: '123456789',
+        fromBase: 10,
+        toBase: 36,
+      });
+
+      expect(result.success).toBe(true);
+      expect(result.content).toBe('21I3V9');
+    });
+
+    it('should handle invalid base error', async () => {
+      const result = await calculatorExecutor.convertBase({
+        number: '123',
+        fromBase: 1, // Invalid base
+        toBase: 10,
+      });
+
+      expect(result.success).toBe(false);
+      expect(result.error?.type).toBe('ConversionError');
+      expect(result.error?.message).toContain('Base must be between 2 and 36');
+    });
+
+    it('should handle invalid digit error', async () => {
+      const result = await calculatorExecutor.convertBase({
+        number: 'G', // Invalid digit for hex
+        fromBase: 16,
+        toBase: 10,
+      });
+
+      expect(result.success).toBe(false);
+      expect(result.error?.type).toBe('ConversionError');
+      expect(result.error?.message).toContain('Invalid digit');
+    });
+
+    it('should handle decimal input with parseInt behavior', async () => {
+      const result = await calculatorExecutor.convertBase({
+        number: '15.5',
+        fromBase: 10,
+        toBase: 2,
+      });
+
+      // parseInt will only handle integer part, decimal part is ignored
+      expect(result.success).toBe(true);
+      expect(result.content).toBe('1111');
+    });
+  });
+
+  describe('error handling', () => {
+    it('should handle division by zero', async () => {
+      const result = await calculatorExecutor.calculate({
+        expression: '1 / 0',
+      });
+
+      // mathjs handles division by zero as Infinity
+      expect(result.success).toBe(true);
+      expect(result.content).toBe('Infinity');
+    });
+
+    it('should handle expression evaluation errors gracefully', async () => {
+      const result = await calculatorExecutor.evaluateExpression({
+        expression: 'x ^^^^^ y',
+        variables: { x: 1, y: 2 },
+      });
+
+      expect(result.success).toBe(false);
+      expect(result.error?.type).toBe('CalculationError');
+    });
+
+    it('should preserve state information on errors', async () => {
+      const result = await calculatorExecutor.calculate({
+        expression: 'invalid',
+      });
+
+      expect(result.success).toBe(false);
+      expect(result.content).toContain('Calculation error');
+      expect(result.error?.message).toBeDefined();
+    });
+  });
+});
diff --git a/packages/builtin-tool-calculator/src/client/index.ts b/packages/builtin-tool-calculator/src/client/index.ts
new file mode 100644
index 0000000000000..2861ba06d85d3
--- /dev/null
+++ b/packages/builtin-tool-calculator/src/client/index.ts
@@ -0,0 +1,5 @@
+// Client-side exports for the Calculator tool
+
+export { CalculatorManifest } from '../manifest';
+export { calculatorExecutor } from '../executor';
+export * from '../types';
\ No newline at end of file
diff --git a/packages/builtin-tool-calculator/src/executor/index.ts b/packages/builtin-tool-calculator/src/executor/index.ts
new file mode 100644
index 0000000000000..6b8ee73776049
--- /dev/null
+++ b/packages/builtin-tool-calculator/src/executor/index.ts
@@ -0,0 +1,256 @@
+import { BaseExecutor, type BuiltinToolResult, type IBuiltinToolExecutor } from '@lobechat/types';
+import { all, create } from 'mathjs';
+
+import {
+  type CalculateParams,
+  CalculatorApiName,
+  CalculatorIdentifier,
+  type ConvertBaseParams,
+  type EvaluateExpressionParams,
+} from '../types';
+
+// Create a mathjs instance with all functions
+const math = create(all);
+
+/**
+ * Calculator Tool Executor
+ *
+ * Handles mathematical calculations and expression evaluations using mathjs library.
+ */
+class CalculatorExecutor
+  extends BaseExecutor<typeof CalculatorApiName>
+  implements IBuiltinToolExecutor
+{
+  readonly identifier = CalculatorIdentifier;
+  protected readonly apiEnum = CalculatorApiName;
+
+  /**
+   * Safely evaluate a mathematical expression using mathjs
+   */
+  private evaluateMathExpression(expression: string, variables: Record<string, number> = {}): any {
+    try {
+      // Parse the expression with mathjs
+      const node = math.parse(expression);
+
+      // Compile and evaluate with variables
+      const compiled = node.compile();
+      const result = compiled.evaluate(variables);
+
+      return result;
+    } catch (error) {
+      throw new Error(
+        `Failed to evaluate expression: ${error instanceof Error ? error.message : 'Unknown error'}`,
+      );
+    }
+  }
+
+  /**
+   * Format result based on type and precision
+   */
+  private formatResult(result: any, precision?: number): string {
+    if (typeof result === 'number') {
+      if (precision !== undefined) {
+        return result.toFixed(precision);
+      }
+      return result.toString();
+    }
+
+    if (typeof result === 'bigint') {
+      return result.toString();
+    }
+
+    if (typeof result === 'string') {
+      return result;
+    }
+
+    // Handle complex numbers, matrices, etc.
+    return math.format(result, { precision: precision || 10 });
+  }
+
+  /**
+   * Format expression with variables for display
+   */
+  private formatExpression(expression: string, variables: Record<string, number>): string {
+    if (Object.keys(variables).length === 0) {
+      return expression;
+    }
+
+    const varStr = Object.entries(variables)
+      .map(([key, value]) => `${key} = ${value}`)
+      .join(', ');
+    return `${expression} (where ${varStr})`;
+  }
+
+  /**
+   * Convert number to target base with clean formatting
+   */
+  private convertToBase(decimalValue: number, targetBase: number): string {
+    return decimalValue.toString(targetBase).toUpperCase();
+  }
+
+  /**
+   * Clean and validate input number
+   */
+  private cleanInputNumber(number: string | number, sourceBase: number): string {
+    const trimmed = String(number).trim();
+
+    // Validate base range
+    if (sourceBase < 2 || sourceBase > 36) {
+      throw new Error(`Base must be between 2 and 36, got ${sourceBase}`);
+    }
+
+    // Validate that the number contains only valid characters for the base
+    const validChars = new Set('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.slice(0, sourceBase));
+    for (const char of trimmed.toUpperCase()) {
+      // Allow decimal points for parseInt compatibility (parseInt ignores decimal part)
+      if (char === '.') continue;
+
+      if (!validChars.has(char)) {
+        throw new Error(`Invalid digit '${char}' for base ${sourceBase}`);
+      }
+    }
+
+    return trimmed;
+  }
+
+  /**
+   * Calculate a mathematical expression
+   */
+  calculate = async (params: CalculateParams): Promise<BuiltinToolResult> => {
+    try {
+      const result = this.evaluateMathExpression(params.expression);
+
+      if (result === undefined) {
+        return {
+          content: `Cannot evaluate expression: "${params.expression}"`,
+          error: {
+            message: 'Expression resulted in undefined',
+            type: 'ValidationError',
+          },
+          success: false,
+        };
+      }
+
+      const formattedResult = this.formatResult(result, params.precision);
+
+      return {
+        content: formattedResult,
+        state: {
+          expression: params.expression,
+          precision: params.precision,
+          result: formattedResult,
+        },
+        success: true,
+      };
+    } catch (error) {
+      const err = error as Error;
+      return {
+        content: `Calculation error: ${err.message}`,
+        error: {
+          message: err.message,
+          type: 'CalculationError',
+        },
+        success: false,
+      };
+    }
+  };
+
+  /**
+   * Evaluate a complex mathematical expression with variables
+   */
+  evaluateExpression = async (params: EvaluateExpressionParams): Promise<BuiltinToolResult> => {
+    try {
+      const variables = params.variables || {};
+      const result = this.evaluateMathExpression(params.expression, variables);
+
+      if (result === undefined) {
+        return {
+          content: `Cannot evaluate expression: "${params.expression}"`,
+          error: {
+            message: 'Expression resulted in undefined',
+            type: 'ValidationError',
+          },
+          success: false,
+        };
+      }
+
+      const formattedResult = this.formatResult(result, params.precision);
+
+      return {
+        content: formattedResult,
+        state: {
+          expression: params.expression,
+          precision: params.precision,
+          result: formattedResult,
+          variables,
+        },
+        success: true,
+      };
+    } catch (error) {
+      const err = error as Error;
+      return {
+        content: `Expression evaluation error: ${err.message}`,
+        error: {
+          message: err.message,
+          type: 'CalculationError',
+        },
+        success: false,
+      };
+    }
+  };
+
+  /**
+   * Convert numbers between different bases (supports bases 2-36)
+   */
+  convertBase = async (params: ConvertBaseParams): Promise<BuiltinToolResult> => {
+    try {
+      const { number, fromBase, toBase } = params;
+
+      // Clean and validate input number
+      const cleanNumber = this.cleanInputNumber(number, fromBase);
+
+      // Convert to decimal first using optimized parseInt
+      const decimalValue = parseInt(cleanNumber, fromBase);
+      if (isNaN(decimalValue)) {
+        throw new Error(`Invalid number "${number}" for base ${fromBase}`);
+      }
+
+      // Convert to target base
+      const convertedNumber = this.convertToBase(decimalValue, toBase);
+
+      return {
+        content: convertedNumber,
+        state: {
+          convertedNumber,
+          decimalValue,
+          originalBase: fromBase,
+          originalNumber: number,
+          targetBase: toBase,
+        },
+        success: true,
+      };
+    } catch (error) {
+      const err = error as Error;
+      return {
+        content: `Base conversion error: ${err.message}`,
+        error: {
+          message: err.message,
+          type: 'ConversionError',
+        },
+        success: false,
+      };
+    }
+  };
+
+  // Implement required interface methods
+  getApiNames(): string[] {
+    return Object.values(this.apiEnum) as string[];
+  }
+
+  hasApi(apiName: string): boolean {
+    return (Object.values(this.apiEnum) as string[]).includes(apiName);
+  }
+}
+
+// Export the executor instance for registration
+export const calculatorExecutor = new CalculatorExecutor();
diff --git a/packages/builtin-tool-calculator/src/index.ts b/packages/builtin-tool-calculator/src/index.ts
new file mode 100644
index 0000000000000..4779e6e4d607f
--- /dev/null
+++ b/packages/builtin-tool-calculator/src/index.ts
@@ -0,0 +1,11 @@
+export { CalculatorManifest } from './manifest';
+export { systemPrompt } from './systemRole';
+export {
+  type CalculateParams,
+  type CalculateState,
+  CalculatorApiName,
+  type CalculatorApiNameType,
+  CalculatorIdentifier,
+  type EvaluateExpressionParams,
+  type EvaluateExpressionState,
+} from './types';
diff --git a/packages/builtin-tool-calculator/src/manifest.ts b/packages/builtin-tool-calculator/src/manifest.ts
new file mode 100644
index 0000000000000..6a139b6373d11
--- /dev/null
+++ b/packages/builtin-tool-calculator/src/manifest.ts
@@ -0,0 +1,96 @@
+import type { BuiltinToolManifest } from '@lobechat/types';
+
+import { systemPrompt } from './systemRole';
+import { CalculatorApiName, CalculatorIdentifier } from './types';
+
+export const CalculatorManifest: BuiltinToolManifest = {
+  api: [
+    {
+      description:
+        'Calculate the result of a mathematical expression. Powered by mathjs library supporting comprehensive math functions, matrices, complex numbers, units, and symbolic calculations.',
+      name: CalculatorApiName.calculate,
+      parameters: {
+        additionalProperties: false,
+        properties: {
+          expression: {
+            description:
+              'Mathematical expression to calculate (e.g., "2 + 3 * 4", "sqrt(16)", "sin(30Â°)", "det([[1,2],[3,4]])", "5 cm to inch")',
+            type: 'string',
+          },
+          precision: {
+            description: 'Number of decimal places for the result (optional, defaults to 10)',
+            maximum: 20,
+            minimum: 0,
+            type: 'number',
+          },
+        },
+        required: ['expression'],
+        type: 'object',
+      },
+    },
+    {
+      description:
+        'Evaluate a complex mathematical expression with variable support. Powered by mathjs supporting algebraic expressions, symbolic calculations, matrices, and advanced mathematical operations.',
+      name: CalculatorApiName.evaluateExpression,
+      parameters: {
+        additionalProperties: false,
+        properties: {
+          expression: {
+            description:
+              'Mathematical expression to evaluate (e.g., "x^2 + 2*x + 1", "det([[a,b],[c,d]])", "sqrt(a^2 + b^2)")',
+            type: 'string',
+          },
+          precision: {
+            description: 'Number of decimal places for the result (optional, defaults to 10)',
+            maximum: 20,
+            minimum: 0,
+            type: 'number',
+          },
+          variables: {
+            description:
+              'Key-value pairs of variables to substitute in the expression (e.g., {"x": 5, "r": 3})',
+            type: 'object',
+          },
+        },
+        required: ['expression'],
+        type: 'object',
+      },
+    },
+    {
+      description:
+        'Convert numbers between different number bases (supports bases 2-36). Input number format should match the specified source base.',
+      name: CalculatorApiName.convertBase,
+      parameters: {
+        additionalProperties: false,
+        properties: {
+          fromBase: {
+            description: 'Source base of the input number (numeric value between 2-36)',
+            maximum: 36,
+            minimum: 2,
+            type: 'number',
+          },
+          number: {
+            description:
+              'The number to convert (string or number, e.g., "1010", 1010, "77", "255", "FF", "Z")',
+            type: ['string', 'number'],
+          },
+          toBase: {
+            description: 'Target base for conversion (numeric value between 2-36)',
+            maximum: 36,
+            minimum: 2,
+            type: 'number',
+          },
+        },
+        required: ['number', 'fromBase', 'toBase'],
+        type: 'object',
+      },
+    },
+  ],
+  identifier: CalculatorIdentifier,
+  meta: {
+    avatar: 'ðŸ§®',
+    title: 'Calculator',
+  },
+  systemRole: systemPrompt,
+  type: 'builtin',
+};
diff --git a/packages/builtin-tool-calculator/src/systemRole.ts b/packages/builtin-tool-calculator/src/systemRole.ts
new file mode 100644
index 0000000000000..1105fa45434a2
--- /dev/null
+++ b/packages/builtin-tool-calculator/src/systemRole.ts
@@ -0,0 +1,86 @@
+export const systemPrompt = `You have access to a Calculator tool powered by mathjs, capable of comprehensive mathematical computations and base conversions.
+
+<core_capabilities>
+1. **calculate**: Perform mathematical expressions and calculations using mathjs syntax
+2. **evaluateExpression**: Evaluate complex mathematical expressions with variable substitution
+3. **convertBase**: Convert numbers between different number bases (supports bases 2-36)
+</core_capabilities>
+
+<workflow>
+1. Analyze the user's mathematical or conversion needs
+2. Select the appropriate tool based on the request type
+3. Execute the calculation or conversion with proper parameters
+4. Present clean, direct results without showing the original input
+</workflow>
+
+<tool_selection_guidelines>
+- **calculate**: Use for direct mathematical calculations, expressions, and unit conversions
+  - Examples: "2 + 3 * 4", "sqrt(16)", "sin(30 deg)", "5 cm to inch", "25 degC to degF"
+  - Supports: arithmetic, functions, matrices, complex numbers, units, symbolic calculations
+  - Uses mathjs syntax for all operations
+  
+- **evaluateExpression**: Use for complex expressions requiring variable substitution
+  - Examples: "x^2 + 2*x + 1", "det([[a,b],[c,d]])"
+  - Provide variables object with key-value pairs for substitution
+  
+- **convertBase**: Use for number base conversions
+  - Requires numeric base values (2-36) for both fromBase and toBase parameters
+  - Supports both string and number inputs for the number parameter
+  - Examples: convert "1010" from base 2 to base 10, convert "255" from base 10 to base 16, convert "Z" from base 36 to base 10
+</tool_selection_guidelines>
+
+<mathjs_syntax_guide>
+**Unit Conversions**: Use mathjs unit syntax
+- Temperature: "25 degC to degF" (not "25 Â°C to Â°F")
+- Length: "5 cm to inch", "100 ft to m"
+- Weight: "1 kg to lb", "100 lb to kg"
+- Speed: "100 km/h to mph", "60 mph to km/h"
+- Volume: "1 liter to gallon", "1 gallon to liter"
+
+**Mathematical Functions**: Follow mathjs function names
+- Trigonometry: sin(x), cos(x), tan(x) - angles in radians or use "deg" suffix (sin(30 deg))
+- Constants: pi, e, tau, phi (case insensitive)
+- Logarithms: log(x), log10(x), log2(x)
+- Exponential: exp(x), pow(x,y), sqrt(x)
+
+**Complex Numbers**: Use "i" for imaginary unit
+- Examples: "sqrt(-1)", "3 + 4i", "complex(3,4)"
+</mathjs_syntax_guide>
+
+<supported_operations>
+**Basic Arithmetic**: +, -, *, /, % (modulus)
+**Mathematical Functions**: sqrt, sin, cos, tan, log, exp, abs, round, floor, ceil
+**Advanced Operations**: matrices, complex numbers, derivatives, integrals, statistics
+**Unit Conversions**: Temperature, length, weight, speed, volume using mathjs syntax
+**Base Conversions**: Support for all bases from 2 to 36 (binary, octal, decimal, hexadecimal, and custom bases)
+**Constants**: pi, e, tau, phi, i (case insensitive)
+</supported_operations>
+
+<formatting_guidelines>
+- Return only the result value without showing the original expression or input
+- For unit conversions, return only the converted value with units
+- For base conversions, return only the converted number in the target base
+- Provide intermediate steps when helpful for complex calculations
+- Use the precision parameter when specified for decimal places
+</formatting_guidelines>
+
+<error_handling>
+- If expressions are invalid, explain the specific error clearly
+- For undefined operations, suggest alternatives or clarify requirements
+- When variables are missing from evaluateExpression, the operation will fail
+- For base conversion errors, verify that base values are between 2-36 and the number contains valid digits
+- Handle decimal points gracefully in base conversion inputs
+- For unit conversion errors, verify correct mathjs unit syntax is being used
+</error_handling>
+
+<best_practices>
+- **IMPORTANT**: Use mathjs syntax for all calculations and unit conversions
+- Use "degC" and "degF" instead of Unicode degree symbols for temperature
+- Use "deg" suffix for degree angles in trigonometric functions
+- Simplify complex expressions when possible
+- Use meaningful variable names in expressions
+- For large calculations, consider breaking them into smaller steps
+- Always verify that results make sense in the given context
+- Provide exact decimal values when precision is specified
+- For base conversions, use numeric values instead of string names (e.g., 2 instead of "binary")
+</best_practices>`;
diff --git a/packages/builtin-tool-calculator/src/types.ts b/packages/builtin-tool-calculator/src/types.ts
new file mode 100644
index 0000000000000..c0da40c787d7d
--- /dev/null
+++ b/packages/builtin-tool-calculator/src/types.ts
@@ -0,0 +1,50 @@
+export const CalculatorIdentifier = 'lobe-calculator';
+
+export const CalculatorApiName = {
+  calculate: 'calculate',
+  convertBase: 'convertBase',
+  evaluateExpression: 'evaluateExpression',
+} as const;
+
+export type CalculatorApiNameType = (typeof CalculatorApiName)[keyof typeof CalculatorApiName];
+
+// Calculate API
+export interface CalculateParams {
+  expression: string;
+  precision?: number;
+}
+
+export interface CalculateState {
+  expression?: string;
+  precision?: number;
+  result?: number | string;
+}
+
+// Evaluate Expression API (for more complex mathematical expressions)
+export interface EvaluateExpressionParams {
+  expression: string;
+  precision?: number;
+  variables?: Record<string, number>;
+}
+
+export interface EvaluateExpressionState {
+  expression?: string;
+  precision?: number;
+  result?: number | string;
+  variables?: Record<string, number>;
+}
+
+// Base Conversion API
+export interface ConvertBaseParams {
+  fromBase: number;
+  number: string | number;
+  toBase: number;
+}
+
+export interface ConvertBaseState {
+  convertedNumber?: string;
+  decimalValue?: number;
+  originalBase?: string;
+  originalNumber?: string;
+  targetBase?: string;
+}
diff --git a/packages/builtin-tool-calculator/tsconfig.json b/packages/builtin-tool-calculator/tsconfig.json
new file mode 100644
index 0000000000000..cf07830f64dfc
--- /dev/null
+++ b/packages/builtin-tool-calculator/tsconfig.json
@@ -0,0 +1,18 @@
+{
+  "compilerOptions": {
+    "target": "ES2022",
+    "module": "ESNext",
+    "moduleResolution": "node",
+    "declaration": true,
+    "outDir": "dist",
+    "rootDir": "src",
+    "strict": true,
+    "skipLibCheck": true,
+    "esModuleInterop": true,
+    "allowSyntheticDefaultImports": true,
+    "forceConsistentCasingInFileNames": true,
+    "resolveJsonModule": true
+  },
+  "exclude": ["node_modules"],
+  "include": ["src/**/*"]
+}
diff --git a/src/store/tool/slices/builtin/executors/index.ts b/src/store/tool/slices/builtin/executors/index.ts
index a53a4cc55d5d3..f17dce883ae31 100644
--- a/src/store/tool/slices/builtin/executors/index.ts
+++ b/src/store/tool/slices/builtin/executors/index.ts
@@ -5,6 +5,7 @@
  * Executors are registered as class instances by identifier.
  */
 import { agentBuilderExecutor } from '@lobechat/builtin-tool-agent-builder/executor';
+import { calculatorExecutor } from '@lobechat/builtin-tool-calculator/executor';
 import { cloudSandboxExecutor } from '@lobechat/builtin-tool-cloud-sandbox/executor';
 import { groupAgentBuilderExecutor } from '@lobechat/builtin-tool-group-agent-builder/executor';
 import { groupManagementExecutor } from '@lobechat/builtin-tool-group-management/executor';
@@ -121,6 +122,7 @@ const registerExecutors = (executors: IBuiltinToolExecutor[]): void => {
 // Register all executor instances
 registerExecutors([
   agentBuilderExecutor,
+  calculatorExecutor,
   cloudSandboxExecutor,
   groupAgentBuilderExecutor,
   groupManagementExecutor,
diff --git a/src/tools/identifiers.ts b/src/tools/identifiers.ts
index 5cb29434ed305..555f0d3ae84d2 100644
--- a/src/tools/identifiers.ts
+++ b/src/tools/identifiers.ts
@@ -1,4 +1,5 @@
 import { AgentBuilderManifest } from '@lobechat/builtin-tool-agent-builder';
+import { CalculatorManifest } from '@lobechat/builtin-tool-calculator';
 import { CloudSandboxManifest } from '@lobechat/builtin-tool-cloud-sandbox';
 import { GroupAgentBuilderManifest } from '@lobechat/builtin-tool-group-agent-builder';
 import { GroupManagementManifest } from '@lobechat/builtin-tool-group-management';
@@ -15,6 +16,7 @@ import { ArtifactsManifest } from './artifacts';
 export const builtinToolIdentifiers: string[] = [
   AgentBuilderManifest.identifier,
   ArtifactsManifest.identifier,
+  CalculatorManifest.identifier,
   LocalSystemManifest.identifier,
   WebBrowsingManifest.identifier,
   KnowledgeBaseManifest.identifier,
diff --git a/src/tools/index.ts b/src/tools/index.ts
index 776e35de63beb..13eebc28cd29e 100644
--- a/src/tools/index.ts
+++ b/src/tools/index.ts
@@ -1,4 +1,5 @@
 import { AgentBuilderManifest } from '@lobechat/builtin-tool-agent-builder';
+import { CalculatorManifest } from '@lobechat/builtin-tool-calculator';
 import { CloudSandboxManifest } from '@lobechat/builtin-tool-cloud-sandbox';
 import { GroupAgentBuilderManifest } from '@lobechat/builtin-tool-group-agent-builder';
 import { GroupManagementManifest } from '@lobechat/builtin-tool-group-management';
@@ -20,6 +21,11 @@ export const builtinTools: LobeBuiltinTool[] = [
     manifest: ArtifactsManifest,
     type: 'builtin',
   },
+  {
+    identifier: CalculatorManifest.identifier,
+    manifest: CalculatorManifest,
+    type: 'builtin',
+  },
   {
     hidden: !isDesktop,
     identifier: LocalSystemManifest.identifier,
diff --git a/src/tools/inspectors.ts b/src/tools/inspectors.ts
index b4947fcf6d358..97660b3c748a5 100644
--- a/src/tools/inspectors.ts
+++ b/src/tools/inspectors.ts
@@ -2,6 +2,7 @@ import {
   AgentBuilderInspectors,
   AgentBuilderManifest,
 } from '@lobechat/builtin-tool-agent-builder/client';
+import { CalculatorManifest } from '@lobechat/builtin-tool-calculator';
 import {
   CloudSandboxIdentifier,
   CloudSandboxInspectors,
@@ -41,6 +42,7 @@ import { type BuiltinInspector } from '@lobechat/types';
  */
 const BuiltinToolInspectors: Record<string, Record<string, BuiltinInspector>> = {
   [AgentBuilderManifest.identifier]: AgentBuilderInspectors as Record<string, BuiltinInspector>,
+  [CalculatorManifest.identifier]: {} as Record<string, BuiltinInspector>,
   [CloudSandboxIdentifier]: CloudSandboxInspectors as Record<string, BuiltinInspector>,
   [GroupAgentBuilderManifest.identifier]: GroupAgentBuilderInspectors as Record<
     string,
diff --git a/src/tools/renders.ts b/src/tools/renders.ts
index 782875c94ef1a..8297406bed01f 100644
--- a/src/tools/renders.ts
+++ b/src/tools/renders.ts
@@ -1,5 +1,6 @@
 import { AgentBuilderManifest } from '@lobechat/builtin-tool-agent-builder';
 import { AgentBuilderRenders } from '@lobechat/builtin-tool-agent-builder/client';
+import { CalculatorManifest } from '@lobechat/builtin-tool-calculator';
 import { CloudSandboxManifest } from '@lobechat/builtin-tool-cloud-sandbox';
 import { CloudSandboxRenders } from '@lobechat/builtin-tool-cloud-sandbox/client';
 import { GroupAgentBuilderManifest } from '@lobechat/builtin-tool-group-agent-builder';
@@ -29,6 +30,7 @@ import { type BuiltinRender } from '@lobechat/types';
  */
 const BuiltinToolsRenders: Record<string, Record<string, BuiltinRender>> = {
   [AgentBuilderManifest.identifier]: AgentBuilderRenders as Record<string, BuiltinRender>,
+  [CalculatorManifest.identifier]: {} as Record<string, BuiltinRender>,
   [CloudSandboxManifest.identifier]: CloudSandboxRenders as Record<string, BuiltinRender>,
   [GroupAgentBuilderManifest.identifier]: GroupAgentBuilderRenders as Record<string, BuiltinRender>,
   [GroupManagementManifest.identifier]: GroupManagementRenders as Record<string, BuiltinRender>,
diff --git a/src/tools/streamings.ts b/src/tools/streamings.ts
index 39ffc742746c7..1d0b9f54f0499 100644
--- a/src/tools/streamings.ts
+++ b/src/tools/streamings.ts
@@ -2,6 +2,7 @@ import {
   AgentBuilderManifest,
   AgentBuilderStreamings,
 } from '@lobechat/builtin-tool-agent-builder/client';
+import { CalculatorManifest } from '@lobechat/builtin-tool-calculator';
 import {
   CloudSandboxManifest,
   CloudSandboxStreamings,
@@ -33,6 +34,7 @@ import { type BuiltinStreaming } from '@lobechat/types';
  */
 const BuiltinToolStreamings: Record<string, Record<string, BuiltinStreaming>> = {
   [AgentBuilderManifest.identifier]: AgentBuilderStreamings as Record<string, BuiltinStreaming>,
+  [CalculatorManifest.identifier]: {} as Record<string, BuiltinStreaming>,
   [CloudSandboxManifest.identifier]: CloudSandboxStreamings as Record<string, BuiltinStreaming>,
   [GroupAgentBuilderManifest.identifier]: GroupAgentBuilderStreamings as Record<
     string,
