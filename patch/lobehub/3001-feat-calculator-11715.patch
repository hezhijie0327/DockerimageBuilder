diff --git a/package.json b/package.json
index 428f8d89e4c00..8c2d2e51b61eb 100644
--- a/package.json
+++ b/package.json
@@ -166,6 +166,7 @@
     "@lobechat/agent-runtime": "workspace:*",
     "@lobechat/builtin-agents": "workspace:*",
     "@lobechat/builtin-tool-agent-builder": "workspace:*",
+    "@lobechat/builtin-tool-calculator": "workspace:*",
     "@lobechat/builtin-tool-cloud-sandbox": "workspace:*",
     "@lobechat/builtin-tool-group-agent-builder": "workspace:*",
     "@lobechat/builtin-tool-group-management": "workspace:*",
diff --git a/packages/builtin-tool-calculator/package.json b/packages/builtin-tool-calculator/package.json
new file mode 100644
index 0000000000000..64ea6ea2f7ce7
--- /dev/null
+++ b/packages/builtin-tool-calculator/package.json
@@ -0,0 +1,25 @@
+{
+  "name": "@lobechat/builtin-tool-calculator",
+  "version": "1.0.0",
+  "private": true,
+  "exports": {
+    ".": "./src/index.ts",
+    "./client": "./src/client/index.ts",
+    "./executor": "./src/executor/index.ts"
+  },
+  "main": "./src/index.ts",
+  "dependencies": {
+    "@lobechat/prompts": "workspace:*",
+    "mathjs": "^12.4.3"
+  },
+  "devDependencies": {
+    "@lobechat/types": "workspace:*"
+  },
+  "peerDependencies": {
+    "@lobehub/ui": "^4",
+    "antd-style": "*",
+    "lucide-react": "*",
+    "react": "*",
+    "react-i18next": "*"
+  }
+}
diff --git a/packages/builtin-tool-calculator/src/base-conversion.test.ts b/packages/builtin-tool-calculator/src/base-conversion.test.ts
new file mode 100644
index 0000000000000..41c223acbabc9
--- /dev/null
+++ b/packages/builtin-tool-calculator/src/base-conversion.test.ts
@@ -0,0 +1,133 @@
+import { describe, expect, it } from 'vitest';
+
+import { calculatorExecutor } from '../src/executor';
+
+describe('Calculator Base Conversion', () => {
+  it('should convert binary to decimal', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: '1010',
+      fromBase: 2,
+      toBase: 10,
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('10');
+    expect(result.state?.decimalValue).toBe(10);
+  });
+
+  it('should convert decimal to binary', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: '255',
+      fromBase: 10,
+      toBase: 2,
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('11111111');
+    expect(result.state?.decimalValue).toBe(255);
+  });
+
+  it('should convert hexadecimal to octal', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: 'FF',
+      fromBase: 16,
+      toBase: 8,
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('377');
+    expect(result.state?.decimalValue).toBe(255);
+  });
+
+  it('should convert octal to hexadecimal', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: '77',
+      fromBase: 8,
+      toBase: 16,
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('3F');
+    expect(result.state?.decimalValue).toBe(63);
+  });
+
+  it('should handle hexadecimal input', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: 'FF',
+      fromBase: 16,
+      toBase: 10,
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('255');
+    expect(result.state?.decimalValue).toBe(255);
+  });
+
+  it('should handle invalid numbers', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: '2AB',
+      fromBase: 2,
+      toBase: 10,
+    });
+
+    expect(result.success).toBe(false);
+    expect(result.error?.type).toBe('ConversionError');
+  });
+
+  it('should support bases 2-36 with numeric input', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: 'Z',
+      fromBase: 36,
+      toBase: 10,
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('35');
+    expect(result.state?.decimalValue).toBe(35);
+  });
+
+  it('should convert decimal to base 32', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: '1000',
+      fromBase: 10,
+      toBase: 32,
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('V8');
+    expect(result.state?.decimalValue).toBe(1000);
+  });
+
+  it('should handle invalid base numbers', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: '123',
+      fromBase: 1,
+      toBase: 10,
+    });
+
+    expect(result.success).toBe(false);
+    expect(result.error?.type).toBe('ConversionError');
+  });
+
+  it('should handle invalid base 37', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: '123',
+      fromBase: 10,
+      toBase: 37,
+    });
+
+    expect(result.success).toBe(false);
+    expect(result.error?.type).toBe('ConversionError');
+  });
+
+  it('should validate digit characters for base', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: 'G',
+      fromBase: 16,
+      toBase: 10,
+    });
+
+    expect(result.success).toBe(false);
+    expect(result.error?.type).toBe('ConversionError');
+  });
+});
diff --git a/packages/builtin-tool-calculator/src/calculate.test.ts b/packages/builtin-tool-calculator/src/calculate.test.ts
new file mode 100644
index 0000000000000..a49d30bdcd635
--- /dev/null
+++ b/packages/builtin-tool-calculator/src/calculate.test.ts
@@ -0,0 +1,56 @@
+import { describe, expect, it } from 'vitest';
+
+import { calculatorExecutor } from '../src/executor';
+
+describe('Calculator Core Functions', () => {
+  it('should handle number input in base conversion', async () => {
+    const result = await calculatorExecutor.convertBase({
+      number: 255,
+      fromBase: 10,
+      toBase: 2,
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('11111111');
+  });
+
+  it('should return only result for calculate', async () => {
+    const result = await calculatorExecutor.calculate({
+      expression: '2 + 3 * 4',
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('14');
+    expect(result.state?.result).toBe('14');
+  });
+
+  it('should return only result for evaluateExpression', async () => {
+    const result = await calculatorExecutor.evaluateExpression({
+      expression: 'x^2 + 2*x + 1',
+      variables: { x: 5 },
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('36');
+    expect(result.state?.result).toBe('36');
+  });
+
+  it('should handle precision in calculate', async () => {
+    const result = await calculatorExecutor.calculate({
+      expression: '10 / 3',
+      precision: 2,
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('3.33');
+  });
+
+  it('should handle complex expressions', async () => {
+    const result = await calculatorExecutor.calculate({
+      expression: 'sqrt(16)',
+    });
+
+    expect(result.success).toBe(true);
+    expect(result.content).toBe('4');
+  });
+});
diff --git a/packages/builtin-tool-calculator/src/client/index.ts b/packages/builtin-tool-calculator/src/client/index.ts
new file mode 100644
index 0000000000000..2861ba06d85d3
--- /dev/null
+++ b/packages/builtin-tool-calculator/src/client/index.ts
@@ -0,0 +1,5 @@
+// Client-side exports for the Calculator tool
+
+export { CalculatorManifest } from '../manifest';
+export { calculatorExecutor } from '../executor';
+export * from '../types';
\ No newline at end of file
diff --git a/packages/builtin-tool-calculator/src/executor/index.ts b/packages/builtin-tool-calculator/src/executor/index.ts
new file mode 100644
index 0000000000000..3ab5ae747e54e
--- /dev/null
+++ b/packages/builtin-tool-calculator/src/executor/index.ts
@@ -0,0 +1,253 @@
+import { BaseExecutor, type BuiltinToolResult, type IBuiltinToolExecutor } from '@lobechat/types';
+import { all, create } from 'mathjs';
+
+import {
+  type CalculateParams,
+  CalculatorApiName,
+  CalculatorIdentifier,
+  type ConvertBaseParams,
+  type EvaluateExpressionParams,
+} from '../types';
+
+// Create a mathjs instance with all functions
+const math = create(all);
+
+/**
+ * Calculator Tool Executor
+ *
+ * Handles mathematical calculations and expression evaluations using mathjs library.
+ */
+class CalculatorExecutor
+  extends BaseExecutor<typeof CalculatorApiName>
+  implements IBuiltinToolExecutor
+{
+  readonly identifier = CalculatorIdentifier;
+  protected readonly apiEnum = CalculatorApiName;
+
+  /**
+   * Safely evaluate a mathematical expression using mathjs
+   */
+  private evaluateMathExpression(expression: string, variables: Record<string, number> = {}): any {
+    try {
+      // Parse the expression with mathjs
+      const node = math.parse(expression);
+
+      // Compile and evaluate with variables
+      const compiled = node.compile();
+      const result = compiled.evaluate(variables);
+
+      return result;
+    } catch (error) {
+      throw new Error(
+        `Failed to evaluate expression: ${error instanceof Error ? error.message : 'Unknown error'}`,
+      );
+    }
+  }
+
+  /**
+   * Format result based on type and precision
+   */
+  private formatResult(result: any, precision?: number): string {
+    if (typeof result === 'number') {
+      if (precision !== undefined) {
+        return result.toFixed(precision);
+      }
+      return result.toString();
+    }
+
+    if (typeof result === 'bigint') {
+      return result.toString();
+    }
+
+    if (typeof result === 'string') {
+      return result;
+    }
+
+    // Handle complex numbers, matrices, etc.
+    return math.format(result, { precision: precision || 10 });
+  }
+
+  /**
+   * Format expression with variables for display
+   */
+  private formatExpression(expression: string, variables: Record<string, number>): string {
+    if (Object.keys(variables).length === 0) {
+      return expression;
+    }
+
+    const varStr = Object.entries(variables)
+      .map(([key, value]) => `${key} = ${value}`)
+      .join(', ');
+    return `${expression} (where ${varStr})`;
+  }
+
+  /**
+   * Convert number to target base with clean formatting
+   */
+  private convertToBase(decimalValue: number, targetBase: number): string {
+    return decimalValue.toString(targetBase).toUpperCase();
+  }
+
+  /**
+   * Clean and validate input number
+   */
+  private cleanInputNumber(number: string | number, sourceBase: number): string {
+    const trimmed = String(number).trim();
+
+    // Validate base range
+    if (sourceBase < 2 || sourceBase > 36) {
+      throw new Error(`Base must be between 2 and 36, got ${sourceBase}`);
+    }
+
+    // Validate that the number contains only valid characters for the base
+    const validChars = new Set('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.slice(0, sourceBase));
+    for (const char of trimmed.toUpperCase()) {
+      if (!validChars.has(char)) {
+        throw new Error(`Invalid digit '${char}' for base ${sourceBase}`);
+      }
+    }
+
+    return trimmed;
+  }
+
+  /**
+   * Calculate a mathematical expression
+   */
+  calculate = async (params: CalculateParams): Promise<BuiltinToolResult> => {
+    try {
+      const result = this.evaluateMathExpression(params.expression);
+
+      if (result === undefined) {
+        return {
+          content: `Cannot evaluate expression: "${params.expression}"`,
+          error: {
+            message: 'Expression resulted in undefined',
+            type: 'ValidationError',
+          },
+          success: false,
+        };
+      }
+
+      const formattedResult = this.formatResult(result, params.precision);
+
+      return {
+        content: formattedResult,
+        state: {
+          expression: params.expression,
+          precision: params.precision,
+          result: formattedResult,
+        },
+        success: true,
+      };
+    } catch (error) {
+      const err = error as Error;
+      return {
+        content: `Calculation error: ${err.message}`,
+        error: {
+          message: err.message,
+          type: 'CalculationError',
+        },
+        success: false,
+      };
+    }
+  };
+
+  /**
+   * Evaluate a complex mathematical expression with variables
+   */
+  evaluateExpression = async (params: EvaluateExpressionParams): Promise<BuiltinToolResult> => {
+    try {
+      const variables = params.variables || {};
+      const result = this.evaluateMathExpression(params.expression, variables);
+
+      if (result === undefined) {
+        return {
+          content: `Cannot evaluate expression: "${params.expression}"`,
+          error: {
+            message: 'Expression resulted in undefined',
+            type: 'ValidationError',
+          },
+          success: false,
+        };
+      }
+
+      const formattedResult = this.formatResult(result, params.precision);
+
+      return {
+        content: formattedResult,
+        state: {
+          expression: params.expression,
+          precision: params.precision,
+          result: formattedResult,
+          variables,
+        },
+        success: true,
+      };
+    } catch (error) {
+      const err = error as Error;
+      return {
+        content: `Expression evaluation error: ${err.message}`,
+        error: {
+          message: err.message,
+          type: 'CalculationError',
+        },
+        success: false,
+      };
+    }
+  };
+
+  /**
+   * Convert numbers between different bases (supports bases 2-36)
+   */
+  convertBase = async (params: ConvertBaseParams): Promise<BuiltinToolResult> => {
+    try {
+      const { number, fromBase, toBase } = params;
+
+      // Clean and validate input number
+      const cleanNumber = this.cleanInputNumber(number, fromBase);
+
+      // Convert to decimal first using optimized parseInt
+      const decimalValue = parseInt(cleanNumber, fromBase);
+      if (isNaN(decimalValue)) {
+        throw new Error(`Invalid number "${number}" for base ${fromBase}`);
+      }
+
+      // Convert to target base
+      const convertedNumber = this.convertToBase(decimalValue, toBase);
+
+      return {
+        content: convertedNumber,
+        state: {
+          convertedNumber,
+          decimalValue,
+          originalBase: fromBase,
+          originalNumber: number,
+          targetBase: toBase,
+        },
+        success: true,
+      };
+    } catch (error) {
+      const err = error as Error;
+      return {
+        content: `Base conversion error: ${err.message}`,
+        error: {
+          message: err.message,
+          type: 'ConversionError',
+        },
+        success: false,
+      };
+    }
+  };
+
+  // Implement required interface methods
+  getApiNames(): string[] {
+    return Object.values(this.apiEnum) as string[];
+  }
+
+  hasApi(apiName: string): boolean {
+    return (Object.values(this.apiEnum) as string[]).includes(apiName);
+  }
+}
+
+// Export the executor instance for registration
+export const calculatorExecutor = new CalculatorExecutor();
diff --git a/packages/builtin-tool-calculator/src/index.ts b/packages/builtin-tool-calculator/src/index.ts
new file mode 100644
index 0000000000000..4779e6e4d607f
--- /dev/null
+++ b/packages/builtin-tool-calculator/src/index.ts
@@ -0,0 +1,11 @@
+export { CalculatorManifest } from './manifest';
+export { systemPrompt } from './systemRole';
+export {
+  type CalculateParams,
+  type CalculateState,
+  CalculatorApiName,
+  type CalculatorApiNameType,
+  CalculatorIdentifier,
+  type EvaluateExpressionParams,
+  type EvaluateExpressionState,
+} from './types';
diff --git a/packages/builtin-tool-calculator/src/manifest.ts b/packages/builtin-tool-calculator/src/manifest.ts
new file mode 100644
index 0000000000000..2ea1a3c717781
--- /dev/null
+++ b/packages/builtin-tool-calculator/src/manifest.ts
@@ -0,0 +1,94 @@
+import type { BuiltinToolManifest } from '@lobechat/types';
+
+import { systemPrompt } from './systemRole';
+import { CalculatorApiName, CalculatorIdentifier } from './types';
+
+export const CalculatorManifest: BuiltinToolManifest = {
+  api: [
+    {
+      description:
+        'Calculate the result of a mathematical expression. Powered by mathjs library supporting comprehensive math functions, matrices, complex numbers, units, and symbolic calculations.',
+      name: CalculatorApiName.calculate,
+      parameters: {
+        additionalProperties: false,
+        properties: {
+          expression: {
+            description:
+              'Mathematical expression to calculate (e.g., "2 + 3 * 4", "sqrt(16)", "sin(30Â°)", "det([[1,2],[3,4]])", "5 cm to inch")',
+            type: 'string',
+          },
+          precision: {
+            description: 'Number of decimal places for the result (optional, defaults to 10)',
+            maximum: 20,
+            minimum: 0,
+            type: 'number',
+          },
+        },
+        required: ['expression'],
+        type: 'object',
+      },
+    },
+    {
+      description:
+        'Evaluate a complex mathematical expression with variable support. Powered by mathjs supporting algebraic expressions, symbolic calculations, matrices, and advanced mathematical operations.',
+      name: CalculatorApiName.evaluateExpression,
+      parameters: {
+        additionalProperties: false,
+        properties: {
+          expression: {
+            description:
+              'Mathematical expression to evaluate (e.g., "x^2 + 2*x + 1", "det([[a,b],[c,d]])", "sqrt(a^2 + b^2)")',
+            type: 'string',
+          },
+          precision: {
+            description: 'Number of decimal places for the result (optional, defaults to 10)',
+            maximum: 20,
+            minimum: 0,
+            type: 'number',
+          },
+          variables: {
+            description:
+              'Key-value pairs of variables to substitute in the expression (e.g., {"x": 5, "r": 3})',
+            type: 'object',
+          },
+        },
+        required: ['expression'],
+        type: 'object',
+      },
+    },
+    {
+      description:
+        'Convert numbers between different number bases (binary, octal, decimal, hexadecimal). Input number format should match the specified source base.',
+      name: CalculatorApiName.convertBase,
+      parameters: {
+        additionalProperties: false,
+        properties: {
+          fromBase: {
+            description: 'Source base of the input number',
+            enum: ['binary', 'octal', 'decimal', 'hexadecimal'],
+            type: 'string',
+          },
+          number: {
+            description:
+              'The number to convert (e.g., "1010" for binary, "77" for octal, "255" for decimal, "FF" for hexadecimal)',
+            type: 'string',
+          },
+          toBase: {
+            description: 'Target base for conversion',
+            enum: ['binary', 'octal', 'decimal', 'hexadecimal'],
+            type: 'string',
+          },
+        },
+        required: ['number', 'fromBase', 'toBase'],
+        type: 'object',
+      },
+    },
+  ],
+  identifier: CalculatorIdentifier,
+  meta: {
+    avatar: 'ðŸ§®',
+    title: 'Calculator',
+  },
+  systemRole: systemPrompt,
+  type: 'builtin',
+};
diff --git a/packages/builtin-tool-calculator/src/systemRole.ts b/packages/builtin-tool-calculator/src/systemRole.ts
new file mode 100644
index 0000000000000..67148426ef36d
--- /dev/null
+++ b/packages/builtin-tool-calculator/src/systemRole.ts
@@ -0,0 +1,60 @@
+export const systemPrompt = `You have access to a Calculator tool powered by mathjs, capable of comprehensive mathematical computations and base conversions.
+
+<core_capabilities>
+1. **calculate**: Perform mathematical expressions and calculations (arithmetic, functions, matrices, complex numbers, units, etc.)
+2. **evaluateExpression**: Evaluate complex mathematical expressions with variable substitution
+3. **convertBase**: Convert numbers between different number bases (binary, octal, decimal, hexadecimal)
+</core_capabilities>
+
+<workflow>
+1. Analyze the user's mathematical or conversion needs
+2. Select the appropriate tool based on the request type
+3. Execute the calculation or conversion with proper parameters
+4. Present clear, accurate results with appropriate formatting
+</workflow>
+
+<tool_selection_guidelines>
+- **calculate**: Use for direct mathematical calculations, expressions, and unit conversions
+  - Examples: "2 + 3 * 4", "sqrt(16)", "sin(30Â°)", "5 cm to inch"
+  - Supports: arithmetic, functions, matrices, complex numbers, units, symbolic calculations
+  
+- **evaluateExpression**: Use for complex expressions requiring variable substitution
+  - Examples: "x^2 + 2*x + 1", "det([[a,b],[c,d]])"
+  - Provide variables object with key-value pairs for substitution
+  
+- **convertBase**: Use for number base conversions
+  - Requires explicit source and target bases: 'binary', 'octal', 'decimal', 'hexadecimal'
+  - Supports prefixes in input: 0b (binary), 0o (octal), 0x (hexadecimal)
+  - Examples: convert "1010" from binary to decimal, convert "255" from decimal to hexadecimal
+</tool_selection_guidelines>
+
+<supported_operations>
+**Basic Arithmetic**: +, -, *, /, % (modulus)
+**Mathematical Functions**: sqrt, sin, cos, tan, log, exp, abs, round, floor, ceil
+**Advanced Operations**: matrices, complex numbers, derivatives, integrals, statistics
+**Unit Conversions**: "5 cm to inch", "100 kg to lb", "25Â°C to Â°F"
+**Base Conversions**: Binary â†” Octal â†” Decimal â†” Hexadecimal
+</supported_operations>
+
+<formatting_guidelines>
+- Use proper mathematical notation and clear formatting
+- For unit conversions, show both original and converted units
+- For base conversions, display with appropriate prefixes (0b, 0o, 0x)
+- Provide intermediate steps when helpful for complex calculations
+- Use precision parameter when specified for decimal places
+</formatting_guidelines>
+
+<error_handling>
+- If expressions are invalid, explain the specific error clearly
+- For undefined operations, suggest alternatives or clarify requirements
+- When variables are missing from evaluateExpression, request the missing values
+- For base conversion errors, verify the source base matches the input format
+</error_handling>
+
+<best_practices>
+- Simplify complex expressions when possible
+- Use meaningful variable names in expressions
+- For large calculations, consider breaking them into smaller steps
+- Always verify results make sense in the given context
+- Provide exact decimal values when precision is specified
+</best_practices>`;
diff --git a/packages/builtin-tool-calculator/src/types.ts b/packages/builtin-tool-calculator/src/types.ts
new file mode 100644
index 0000000000000..c0da40c787d7d
--- /dev/null
+++ b/packages/builtin-tool-calculator/src/types.ts
@@ -0,0 +1,50 @@
+export const CalculatorIdentifier = 'lobe-calculator';
+
+export const CalculatorApiName = {
+  calculate: 'calculate',
+  convertBase: 'convertBase',
+  evaluateExpression: 'evaluateExpression',
+} as const;
+
+export type CalculatorApiNameType = (typeof CalculatorApiName)[keyof typeof CalculatorApiName];
+
+// Calculate API
+export interface CalculateParams {
+  expression: string;
+  precision?: number;
+}
+
+export interface CalculateState {
+  expression?: string;
+  precision?: number;
+  result?: number | string;
+}
+
+// Evaluate Expression API (for more complex mathematical expressions)
+export interface EvaluateExpressionParams {
+  expression: string;
+  precision?: number;
+  variables?: Record<string, number>;
+}
+
+export interface EvaluateExpressionState {
+  expression?: string;
+  precision?: number;
+  result?: number | string;
+  variables?: Record<string, number>;
+}
+
+// Base Conversion API
+export interface ConvertBaseParams {
+  fromBase: number;
+  number: string | number;
+  toBase: number;
+}
+
+export interface ConvertBaseState {
+  convertedNumber?: string;
+  decimalValue?: number;
+  originalBase?: string;
+  originalNumber?: string;
+  targetBase?: string;
+}
diff --git a/packages/builtin-tool-calculator/tsconfig.json b/packages/builtin-tool-calculator/tsconfig.json
new file mode 100644
index 0000000000000..cf07830f64dfc
--- /dev/null
+++ b/packages/builtin-tool-calculator/tsconfig.json
@@ -0,0 +1,18 @@
+{
+  "compilerOptions": {
+    "target": "ES2022",
+    "module": "ESNext",
+    "moduleResolution": "node",
+    "declaration": true,
+    "outDir": "dist",
+    "rootDir": "src",
+    "strict": true,
+    "skipLibCheck": true,
+    "esModuleInterop": true,
+    "allowSyntheticDefaultImports": true,
+    "forceConsistentCasingInFileNames": true,
+    "resolveJsonModule": true
+  },
+  "exclude": ["node_modules"],
+  "include": ["src/**/*"]
+}
diff --git a/src/store/tool/slices/builtin/executors/index.ts b/src/store/tool/slices/builtin/executors/index.ts
index a53a4cc55d5d3..f17dce883ae31 100644
--- a/src/store/tool/slices/builtin/executors/index.ts
+++ b/src/store/tool/slices/builtin/executors/index.ts
@@ -5,6 +5,7 @@
  * Executors are registered as class instances by identifier.
  */
 import { agentBuilderExecutor } from '@lobechat/builtin-tool-agent-builder/executor';
+import { calculatorExecutor } from '@lobechat/builtin-tool-calculator/executor';
 import { cloudSandboxExecutor } from '@lobechat/builtin-tool-cloud-sandbox/executor';
 import { groupAgentBuilderExecutor } from '@lobechat/builtin-tool-group-agent-builder/executor';
 import { groupManagementExecutor } from '@lobechat/builtin-tool-group-management/executor';
@@ -121,6 +122,7 @@ const registerExecutors = (executors: IBuiltinToolExecutor[]): void => {
 // Register all executor instances
 registerExecutors([
   agentBuilderExecutor,
+  calculatorExecutor,
   cloudSandboxExecutor,
   groupAgentBuilderExecutor,
   groupManagementExecutor,
diff --git a/src/tools/identifiers.ts b/src/tools/identifiers.ts
index 5cb29434ed305..555f0d3ae84d2 100644
--- a/src/tools/identifiers.ts
+++ b/src/tools/identifiers.ts
@@ -1,4 +1,5 @@
 import { AgentBuilderManifest } from '@lobechat/builtin-tool-agent-builder';
+import { CalculatorManifest } from '@lobechat/builtin-tool-calculator';
 import { CloudSandboxManifest } from '@lobechat/builtin-tool-cloud-sandbox';
 import { GroupAgentBuilderManifest } from '@lobechat/builtin-tool-group-agent-builder';
 import { GroupManagementManifest } from '@lobechat/builtin-tool-group-management';
@@ -15,6 +16,7 @@ import { ArtifactsManifest } from './artifacts';
 export const builtinToolIdentifiers: string[] = [
   AgentBuilderManifest.identifier,
   ArtifactsManifest.identifier,
+  CalculatorManifest.identifier,
   LocalSystemManifest.identifier,
   WebBrowsingManifest.identifier,
   KnowledgeBaseManifest.identifier,
diff --git a/src/tools/index.ts b/src/tools/index.ts
index 776e35de63beb..13eebc28cd29e 100644
--- a/src/tools/index.ts
+++ b/src/tools/index.ts
@@ -1,4 +1,5 @@
 import { AgentBuilderManifest } from '@lobechat/builtin-tool-agent-builder';
+import { CalculatorManifest } from '@lobechat/builtin-tool-calculator';
 import { CloudSandboxManifest } from '@lobechat/builtin-tool-cloud-sandbox';
 import { GroupAgentBuilderManifest } from '@lobechat/builtin-tool-group-agent-builder';
 import { GroupManagementManifest } from '@lobechat/builtin-tool-group-management';
@@ -20,6 +21,11 @@ export const builtinTools: LobeBuiltinTool[] = [
     manifest: ArtifactsManifest,
     type: 'builtin',
   },
+  {
+    identifier: CalculatorManifest.identifier,
+    manifest: CalculatorManifest,
+    type: 'builtin',
+  },
   {
     hidden: !isDesktop,
     identifier: LocalSystemManifest.identifier,
diff --git a/src/tools/inspectors.ts b/src/tools/inspectors.ts
index b4947fcf6d358..97660b3c748a5 100644
--- a/src/tools/inspectors.ts
+++ b/src/tools/inspectors.ts
@@ -2,6 +2,7 @@ import {
   AgentBuilderInspectors,
   AgentBuilderManifest,
 } from '@lobechat/builtin-tool-agent-builder/client';
+import { CalculatorManifest } from '@lobechat/builtin-tool-calculator';
 import {
   CloudSandboxIdentifier,
   CloudSandboxInspectors,
@@ -41,6 +42,7 @@ import { type BuiltinInspector } from '@lobechat/types';
  */
 const BuiltinToolInspectors: Record<string, Record<string, BuiltinInspector>> = {
   [AgentBuilderManifest.identifier]: AgentBuilderInspectors as Record<string, BuiltinInspector>,
+  [CalculatorManifest.identifier]: {} as Record<string, BuiltinInspector>,
   [CloudSandboxIdentifier]: CloudSandboxInspectors as Record<string, BuiltinInspector>,
   [GroupAgentBuilderManifest.identifier]: GroupAgentBuilderInspectors as Record<
     string,
diff --git a/src/tools/renders.ts b/src/tools/renders.ts
index 782875c94ef1a..8297406bed01f 100644
--- a/src/tools/renders.ts
+++ b/src/tools/renders.ts
@@ -1,5 +1,6 @@
 import { AgentBuilderManifest } from '@lobechat/builtin-tool-agent-builder';
 import { AgentBuilderRenders } from '@lobechat/builtin-tool-agent-builder/client';
+import { CalculatorManifest } from '@lobechat/builtin-tool-calculator';
 import { CloudSandboxManifest } from '@lobechat/builtin-tool-cloud-sandbox';
 import { CloudSandboxRenders } from '@lobechat/builtin-tool-cloud-sandbox/client';
 import { GroupAgentBuilderManifest } from '@lobechat/builtin-tool-group-agent-builder';
@@ -29,6 +30,7 @@ import { type BuiltinRender } from '@lobechat/types';
  */
 const BuiltinToolsRenders: Record<string, Record<string, BuiltinRender>> = {
   [AgentBuilderManifest.identifier]: AgentBuilderRenders as Record<string, BuiltinRender>,
+  [CalculatorManifest.identifier]: {} as Record<string, BuiltinRender>,
   [CloudSandboxManifest.identifier]: CloudSandboxRenders as Record<string, BuiltinRender>,
   [GroupAgentBuilderManifest.identifier]: GroupAgentBuilderRenders as Record<string, BuiltinRender>,
   [GroupManagementManifest.identifier]: GroupManagementRenders as Record<string, BuiltinRender>,
diff --git a/src/tools/streamings.ts b/src/tools/streamings.ts
index 39ffc742746c7..1d0b9f54f0499 100644
--- a/src/tools/streamings.ts
+++ b/src/tools/streamings.ts
@@ -2,6 +2,7 @@ import {
   AgentBuilderManifest,
   AgentBuilderStreamings,
 } from '@lobechat/builtin-tool-agent-builder/client';
+import { CalculatorManifest } from '@lobechat/builtin-tool-calculator';
 import {
   CloudSandboxManifest,
   CloudSandboxStreamings,
@@ -33,6 +34,7 @@ import { type BuiltinStreaming } from '@lobechat/types';
  */
 const BuiltinToolStreamings: Record<string, Record<string, BuiltinStreaming>> = {
   [AgentBuilderManifest.identifier]: AgentBuilderStreamings as Record<string, BuiltinStreaming>,
+  [CalculatorManifest.identifier]: {} as Record<string, BuiltinStreaming>,
   [CloudSandboxManifest.identifier]: CloudSandboxStreamings as Record<string, BuiltinStreaming>,
   [GroupAgentBuilderManifest.identifier]: GroupAgentBuilderStreamings as Record<
     string,
