diff --git a/packages/model-bank/src/aiModels/xai.ts b/packages/model-bank/src/aiModels/xai.ts
index 18bb38af81..6268e104d3 100644
--- a/packages/model-bank/src/aiModels/xai.ts
+++ b/packages/model-bank/src/aiModels/xai.ts
@@ -291,6 +291,88 @@ const xaiChatModels: AIChatModelCard[] = [
 ];
 
 const xaiImageModels: AIImageModelCard[] = [
+  {
+    description:
+      'Generate images from text prompts, edit existing images with natural language, or iteratively refine images through multi-turn conversations.',
+    displayName: 'Grok Imagine Image Pro',
+    enabled: true,
+    id: 'grok-imagine-image-pro',
+    parameters: {
+      aspectRatio: {
+        default: 'auto',
+        enum: [
+          'auto',
+          '1:1',
+          '3:4',
+          '4:3',
+          '9:16',
+          '16:9',
+          '2:3',
+          '3:2',
+          '9:19.5',
+          '19.5:9',
+          '9:20',
+          '20:9',
+          '1:2',
+          '2:1',
+        ],
+      },
+      imageUrls: { default: [] },
+      prompt: {
+        default: '',
+      },
+      resolution: {
+        default: '1k',
+        enum: ['1k', '2k'],
+      },
+    },
+    pricing: {
+      units: [{ name: 'imageGeneration', rate: 0.07, strategy: 'fixed', unit: 'image' }],
+    },
+    releasedAt: '2026-01-28',
+    type: 'image',
+  },
+  {
+    description:
+      'Generate images from text prompts, edit existing images with natural language, or iteratively refine images through multi-turn conversations.',
+    displayName: 'Grok Imagine Image',
+    enabled: true,
+    id: 'grok-imagine-image',
+    parameters: {
+      aspectRatio: {
+        default: 'auto',
+        enum: [
+          'auto',
+          '1:1',
+          '3:4',
+          '4:3',
+          '9:16',
+          '16:9',
+          '2:3',
+          '3:2',
+          '9:19.5',
+          '19.5:9',
+          '9:20',
+          '20:9',
+          '1:2',
+          '2:1',
+        ],
+      },
+      imageUrls: { default: [] },
+      prompt: {
+        default: '',
+      },
+      resolution: {
+        default: '1k',
+        enum: ['1k', '2k'],
+      },
+    },
+    pricing: {
+      units: [{ name: 'imageGeneration', rate: 0.02, strategy: 'fixed', unit: 'image' }],
+    },
+    releasedAt: '2026-01-28',
+    type: 'image',
+  },
   {
     description:
       'Our latest image generation model creates vivid, realistic images from prompts and excels in marketing, social media, and entertainment use cases.',
@@ -302,6 +384,9 @@ const xaiImageModels: AIImageModelCard[] = [
         default: '',
       },
     },
+    pricing: {
+      units: [{ name: 'imageGeneration', rate: 0.07, strategy: 'fixed', unit: 'image' }],
+    },
     releasedAt: '2024-12-12',
     type: 'image',
   },
diff --git a/packages/model-runtime/src/providers/xai/createImage.test.ts b/packages/model-runtime/src/providers/xai/createImage.test.ts
new file mode 100644
index 0000000000..627d9fc1d3
--- /dev/null
+++ b/packages/model-runtime/src/providers/xai/createImage.test.ts
@@ -0,0 +1,602 @@
+// @vitest-environment node
+import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
+
+import type { CreateImageOptions } from '../../core/openaiCompatibleFactory';
+import type { CreateImagePayload } from '../../types/image';
+import { createXAIImage } from './createImage';
+
+// Mock the console.error to avoid polluting test output
+vi.spyOn(console, 'error').mockImplementation(() => {});
+
+const mockOptions: CreateImageOptions = {
+  apiKey: 'test-api-key',
+  baseURL: 'https://api.x.ai/v1',
+  provider: 'xai',
+};
+
+beforeEach(() => {
+  // Reset all mocks before each test
+  vi.clearAllMocks();
+});
+
+afterEach(() => {
+  vi.clearAllMocks();
+});
+
+describe('createXAIImage', () => {
+  describe('Success scenarios', () => {
+    it('should successfully generate image with basic prompt', async () => {
+      const mockImageUrl = 'https://xai-cdn.com/images/generated/test-image.jpg';
+
+      global.fetch = vi.fn().mockResolvedValueOnce({
+        ok: true,
+        json: async () => ({
+          data: [
+            {
+              url: mockImageUrl,
+              revised_prompt: 'A beautiful sunset over the mountains',
+            },
+          ],
+        }),
+      });
+
+      const payload: CreateImagePayload = {
+        model: 'grok-imagine-image',
+        params: {
+          prompt: 'A beautiful sunset over the mountains',
+        },
+      };
+
+      const result = await createXAIImage(payload, mockOptions);
+
+      expect(fetch).toHaveBeenCalledWith('https://api.x.ai/v1/images/generations', {
+        method: 'POST',
+        headers: {
+          'Authorization': 'Bearer test-api-key',
+          'Content-Type': 'application/json',
+        },
+        body: JSON.stringify({
+          model: 'grok-imagine-image',
+          prompt: 'A beautiful sunset over the mountains',
+        }),
+      });
+
+      expect(result).toEqual({
+        imageUrl: mockImageUrl,
+      });
+    });
+
+    it('should handle custom aspect ratio', async () => {
+      const mockImageUrl = 'https://xai-cdn.com/images/generated/custom-ratio.jpg';
+
+      global.fetch = vi.fn().mockResolvedValueOnce({
+        ok: true,
+        json: async () => ({
+          data: [
+            {
+              url: mockImageUrl,
+              revised_prompt: 'Abstract digital art',
+            },
+          ],
+        }),
+      });
+
+      const payload: CreateImagePayload = {
+        model: 'grok-imagine-image',
+        params: {
+          prompt: 'Abstract digital art',
+          aspectRatio: '16:9',
+        },
+      };
+
+      const result = await createXAIImage(payload, mockOptions);
+
+      expect(fetch).toHaveBeenCalledWith(
+        'https://api.x.ai/v1/images/generations',
+        expect.objectContaining({
+          body: JSON.stringify({
+            model: 'grok-imagine-image',
+            prompt: 'Abstract digital art',
+            aspect_ratio: '16:9',
+          }),
+        }),
+      );
+
+      expect(result).toEqual({
+        imageUrl: mockImageUrl,
+      });
+    });
+
+    it('should include aspect_ratio when value is auto', async () => {
+      const mockImageUrl = 'https://xai-cdn.com/images/generated/auto-ratio.jpg';
+
+      global.fetch = vi.fn().mockResolvedValueOnce({
+        ok: true,
+        json: async () => ({
+          data: [
+            {
+              url: mockImageUrl,
+              revised_prompt: 'Abstract digital art',
+            },
+          ],
+        }),
+      });
+
+      const payload: CreateImagePayload = {
+        model: 'grok-imagine-image',
+        params: {
+          prompt: 'Abstract digital art',
+          aspectRatio: 'auto',
+        },
+      };
+
+      const result = await createXAIImage(payload, mockOptions);
+
+      expect(fetch).toHaveBeenCalledWith(
+        'https://api.x.ai/v1/images/generations',
+        expect.objectContaining({
+          body: JSON.stringify({
+            model: 'grok-imagine-image',
+            prompt: 'Abstract digital art',
+            aspect_ratio: 'auto',
+          }),
+        }),
+      );
+
+      expect(result).toEqual({
+        imageUrl: mockImageUrl,
+      });
+    });
+
+    it('should handle resolution parameter', async () => {
+      const mockImageUrl = 'https://xai-cdn.com/images/generated/2k-image.jpg';
+
+      global.fetch = vi.fn().mockResolvedValueOnce({
+        ok: true,
+        json: async () => ({
+          data: [
+            {
+              url: mockImageUrl,
+              revised_prompt: 'An astronaut performing EVA in LEO',
+            },
+          ],
+        }),
+      });
+
+      const payload: CreateImagePayload = {
+        model: 'grok-imagine-image',
+        params: {
+          prompt: 'An astronaut performing EVA in LEO',
+          resolution: '2k',
+        },
+      };
+
+      const result = await createXAIImage(payload, mockOptions);
+
+      expect(fetch).toHaveBeenCalledWith(
+        'https://api.x.ai/v1/images/generations',
+        expect.objectContaining({
+          body: JSON.stringify({
+            model: 'grok-imagine-image',
+            prompt: 'An astronaut performing EVA in LEO',
+            resolution: '2k',
+          }),
+        }),
+      );
+
+      expect(result).toEqual({
+        imageUrl: mockImageUrl,
+      });
+    });
+
+    it('should include resolution when value is 1k', async () => {
+      const mockImageUrl = 'https://xai-cdn.com/images/generated/1k-res.jpg';
+
+      global.fetch = vi.fn().mockResolvedValueOnce({
+        ok: true,
+        json: async () => ({
+          data: [
+            {
+              url: mockImageUrl,
+              revised_prompt: 'Test image',
+            },
+          ],
+        }),
+      });
+
+      const payload: CreateImagePayload = {
+        model: 'grok-imagine-image',
+        params: {
+          prompt: 'Test image',
+          resolution: '1k',
+        },
+      };
+
+      const result = await createXAIImage(payload, mockOptions);
+
+      expect(fetch).toHaveBeenCalledWith(
+        'https://api.x.ai/v1/images/generations',
+        expect.objectContaining({
+          body: JSON.stringify({
+            model: 'grok-imagine-image',
+            prompt: 'Test image',
+            resolution: '1k',
+          }),
+        }),
+      );
+
+      expect(result).toEqual({
+        imageUrl: mockImageUrl,
+      });
+    });
+
+    it('should handle image editing mode with imageUrl', async () => {
+      const mockImageUrl = 'https://xai-cdn.com/images/generated/edited-image.jpg';
+
+      global.fetch = vi.fn().mockResolvedValueOnce({
+        ok: true,
+        json: async () => ({
+          data: [
+            {
+              url: mockImageUrl,
+              revised_prompt: 'Change the landmarks to be New York City landmarks',
+            },
+          ],
+        }),
+      });
+
+      const payload: CreateImagePayload = {
+        model: 'grok-imagine-image',
+        params: {
+          prompt: 'Change the landmarks to be New York City landmarks',
+          imageUrl: 'https://example.com/landmarks.jpg',
+        },
+      };
+
+      const result = await createXAIImage(payload, mockOptions);
+
+      expect(fetch).toHaveBeenCalledWith(
+        'https://api.x.ai/v1/images/edits',
+        expect.objectContaining({
+          body: JSON.stringify({
+            model: 'grok-imagine-image',
+            prompt: 'Change the landmarks to be New York City landmarks',
+            image: {
+              type: 'image_url',
+              url: 'https://example.com/landmarks.jpg',
+            },
+          }),
+        }),
+      );
+
+      expect(result).toEqual({
+        imageUrl: mockImageUrl,
+      });
+    });
+
+    it('should not include aspectRatio in image editing mode', async () => {
+      const mockImageUrl = 'https://xai-cdn.com/images/generated/edited-no-aspect.jpg';
+
+      global.fetch = vi.fn().mockResolvedValueOnce({
+        ok: true,
+        json: async () => ({
+          data: [
+            {
+              url: mockImageUrl,
+              revised_prompt: 'Change the landmarks to be New York City landmarks',
+            },
+          ],
+        }),
+      });
+
+      const payload: CreateImagePayload = {
+        model: 'grok-imagine-image',
+        params: {
+          prompt: 'Change the landmarks to be New York City landmarks',
+          imageUrl: 'https://example.com/landmarks.jpg',
+          aspectRatio: '16:9',
+        },
+      };
+
+      const result = await createXAIImage(payload, mockOptions);
+
+      expect(fetch).toHaveBeenCalledWith(
+        'https://api.x.ai/v1/images/edits',
+        expect.objectContaining({
+          body: JSON.stringify({
+            model: 'grok-imagine-image',
+            prompt: 'Change the landmarks to be New York City landmarks',
+            image: {
+              type: 'image_url',
+              url: 'https://example.com/landmarks.jpg',
+            },
+          }),
+        }),
+      );
+
+      expect(result).toEqual({
+        imageUrl: mockImageUrl,
+      });
+    });
+
+    it('should handle multiple generated images and return the first one', async () => {
+      const mockImageUrls = [
+        'https://xai-cdn.com/images/generated/image-1.jpg',
+        'https://xai-cdn.com/images/generated/image-2.jpg',
+      ];
+
+      global.fetch = vi.fn().mockResolvedValueOnce({
+        ok: true,
+        json: async () => ({
+          data: [
+            {
+              url: mockImageUrls[0],
+              revised_prompt: 'Multiple images test',
+            },
+            {
+              url: mockImageUrls[1],
+              revised_prompt: 'Multiple images test',
+            },
+          ],
+        }),
+      });
+
+      const payload: CreateImagePayload = {
+        model: 'grok-imagine-image',
+        params: {
+          prompt: 'Multiple images test',
+        },
+      };
+
+      const result = await createXAIImage(payload, mockOptions);
+
+      expect(result).toEqual({
+        imageUrl: mockImageUrls[0], // Should return first image
+      });
+    });
+
+    it('should handle image editing mode with imageUrls', async () => {
+      const mockImageUrl = 'https://xai-cdn.com/images/generated/edited-multi-image.jpg';
+
+      global.fetch = vi.fn().mockResolvedValueOnce({
+        ok: true,
+        json: async () => ({
+          data: [
+            {
+              url: mockImageUrl,
+              revised_prompt: 'Edit multiple images',
+            },
+          ],
+        }),
+      });
+
+      const payload: CreateImagePayload = {
+        model: 'grok-imagine-image',
+        params: {
+          prompt: 'Edit multiple images',
+          imageUrls: ['https://example.com/image1.jpg', 'https://example.com/image2.jpg'],
+        },
+      };
+
+      const result = await createXAIImage(payload, mockOptions);
+
+      expect(fetch).toHaveBeenCalledWith(
+        'https://api.x.ai/v1/images/edits',
+        expect.objectContaining({
+          body: JSON.stringify({
+            model: 'grok-imagine-image',
+            prompt: 'Edit multiple images',
+            images: [
+              {
+                type: 'image_url',
+                url: 'https://example.com/image1.jpg',
+              },
+              {
+                type: 'image_url',
+                url: 'https://example.com/image2.jpg',
+              },
+            ],
+          }),
+        }),
+      );
+
+      expect(result).toEqual({
+        imageUrl: mockImageUrl,
+      });
+    });
+  });
+
+  describe('Error scenarios', () => {
+    it('should handle HTTP error responses', async () => {
+      global.fetch = vi.fn().mockResolvedValueOnce({
+        ok: false,
+        status: 400,
+        statusText: 'Bad Request',
+        json: async () => ({
+          error: {
+            message: 'Invalid prompt format',
+          },
+        }),
+      });
+
+      const payload: CreateImagePayload = {
+        model: 'grok-imagine-image',
+        params: {
+          prompt: 'Invalid prompt',
+        },
+      };
+
+      await expect(createXAIImage(payload, mockOptions)).rejects.toEqual(
+        expect.objectContaining({
+          errorType: 'ProviderBizError',
+          provider: 'xai',
+        }),
+      );
+    });
+
+    it('should handle non-JSON error responses', async () => {
+      global.fetch = vi.fn().mockResolvedValueOnce({
+        ok: false,
+        status: 500,
+        statusText: 'Internal Server Error',
+        json: async () => {
+          throw new Error('Failed to parse JSON');
+        },
+      });
+
+      const payload: CreateImagePayload = {
+        model: 'grok-imagine-image',
+        params: {
+          prompt: 'Test prompt',
+        },
+      };
+
+      await expect(createXAIImage(payload, mockOptions)).rejects.toEqual(
+        expect.objectContaining({
+          errorType: 'ProviderBizError',
+          provider: 'xai',
+        }),
+      );
+    });
+
+    it('should handle empty data array', async () => {
+      global.fetch = vi.fn().mockResolvedValueOnce({
+        ok: true,
+        json: async () => ({
+          data: [],
+        }),
+      });
+
+      const payload: CreateImagePayload = {
+        model: 'grok-imagine-image',
+        params: {
+          prompt: 'Empty result test',
+        },
+      };
+
+      await expect(createXAIImage(payload, mockOptions)).rejects.toEqual(
+        expect.objectContaining({
+          errorType: 'ProviderBizError',
+          provider: 'xai',
+        }),
+      );
+    });
+
+    it('should handle missing data field', async () => {
+      global.fetch = vi.fn().mockResolvedValueOnce({
+        ok: true,
+        json: async () => ({}),
+      });
+
+      const payload: CreateImagePayload = {
+        model: 'grok-imagine-image',
+        params: {
+          prompt: 'Missing data test',
+        },
+      };
+
+      await expect(createXAIImage(payload, mockOptions)).rejects.toEqual(
+        expect.objectContaining({
+          errorType: 'ProviderBizError',
+          provider: 'xai',
+        }),
+      );
+    });
+
+    it('should handle null/empty image URL', async () => {
+      global.fetch = vi.fn().mockResolvedValueOnce({
+        ok: true,
+        json: async () => ({
+          data: [
+            {
+              url: '',
+              revised_prompt: 'A beautiful sunset over the mountains',
+            },
+          ],
+        }),
+      });
+
+      const payload: CreateImagePayload = {
+        model: 'grok-imagine-image',
+        params: {
+          prompt: 'Empty URL test',
+        },
+      };
+
+      await expect(createXAIImage(payload, mockOptions)).rejects.toEqual(
+        expect.objectContaining({
+          errorType: 'ProviderBizError',
+          provider: 'xai',
+        }),
+      );
+    });
+
+    it('should handle network errors', async () => {
+      global.fetch = vi.fn().mockRejectedValueOnce(new Error('Network connection failed'));
+
+      const payload: CreateImagePayload = {
+        model: 'grok-imagine-image',
+        params: {
+          prompt: 'Network error test',
+        },
+      };
+
+      await expect(createXAIImage(payload, mockOptions)).rejects.toEqual(
+        expect.objectContaining({
+          errorType: 'ProviderBizError',
+          provider: 'xai',
+        }),
+      );
+    });
+
+    it('should handle unauthorized access', async () => {
+      global.fetch = vi.fn().mockResolvedValueOnce({
+        ok: false,
+        status: 401,
+        statusText: 'Unauthorized',
+        json: async () => ({
+          error: {
+            message: 'Invalid API key',
+          },
+        }),
+      });
+
+      const payload: CreateImagePayload = {
+        model: 'grok-imagine-image',
+        params: {
+          prompt: 'Unauthorized test',
+        },
+      };
+
+      await expect(createXAIImage(payload, mockOptions)).rejects.toEqual(
+        expect.objectContaining({
+          errorType: 'ProviderBizError',
+          provider: 'xai',
+        }),
+      );
+    });
+
+    it('should handle malformed JSON response', async () => {
+      global.fetch = vi.fn().mockResolvedValueOnce({
+        ok: true,
+        json: async () => {
+          throw new Error('Unexpected token in JSON');
+        },
+      });
+
+      const payload: CreateImagePayload = {
+        model: 'grok-imagine-image',
+        params: {
+          prompt: 'JSON error test',
+        },
+      };
+
+      await expect(createXAIImage(payload, mockOptions)).rejects.toEqual(
+        expect.objectContaining({
+          errorType: 'ProviderBizError',
+          provider: 'xai',
+        }),
+      );
+    });
+  });
+});
diff --git a/packages/model-runtime/src/providers/xai/createImage.ts b/packages/model-runtime/src/providers/xai/createImage.ts
new file mode 100644
index 0000000000..6ed0fd28d7
--- /dev/null
+++ b/packages/model-runtime/src/providers/xai/createImage.ts
@@ -0,0 +1,151 @@
+import createDebug from 'debug';
+
+import type { CreateImageOptions } from '../../core/openaiCompatibleFactory';
+import type { CreateImagePayload, CreateImageResponse } from '../../types/image';
+import { AgentRuntimeError } from '../../utils/createError';
+
+const log = createDebug('lobe-image:xai');
+
+interface XAIImageRequest {
+  aspect_ratio?:
+    | '1:1'
+    | '3:4'
+    | '4:3'
+    | '9:16'
+    | '16:9'
+    | '2:3'
+    | '3:2'
+    | '9:19.5'
+    | '19.5:9'
+    | '9:20'
+    | '20:9'
+    | '1:2'
+    | '2:1'
+    | 'auto';
+  image?: {
+    type: 'image_url';
+    url: string;
+  };
+  images?: Array<{
+    type: 'image_url';
+    url: string;
+  }>;
+  mask?: {
+    type: 'image_url';
+    url: string;
+  };
+  model: string;
+  n?: number;
+  prompt: string;
+  quality?: 'low' | 'medium' | 'high';
+  resolution?: '1k' | '2k';
+  response_format?: 'url' | 'b64_json';
+  size?: string;
+  style?: string;
+  user?: string;
+}
+
+interface XAIImageData {
+  b64_json?: string | null;
+  revised_prompt: string;
+  url?: string | null;
+}
+
+interface XAIImageResponse {
+  data: XAIImageData[];
+}
+
+/**
+ * Create image using XAI (Grok) API
+ */
+export async function createXAIImage(
+  payload: CreateImagePayload,
+  options: CreateImageOptions,
+): Promise<CreateImageResponse> {
+  const { apiKey, baseURL, provider } = options;
+  const { model, params } = payload;
+
+  try {
+    const hasImageUrl = params.imageUrl && params.imageUrl !== '';
+    const hasImageUrls = params.imageUrls && params.imageUrls.length > 0;
+    const isImageEdit = hasImageUrl || hasImageUrls;
+    const endpoint = isImageEdit ? `${baseURL}/images/edits` : `${baseURL}/images/generations`;
+
+    const requestBody: XAIImageRequest = {
+      model,
+      prompt: params.prompt,
+    };
+
+    if (!isImageEdit && params.aspectRatio) {
+      requestBody.aspect_ratio = params.aspectRatio as XAIImageRequest['aspect_ratio'];
+    }
+
+    if (params.resolution) {
+      requestBody.resolution = params.resolution as XAIImageRequest['resolution'];
+    }
+
+    if (isImageEdit) {
+      if (hasImageUrl && params.imageUrl) {
+        requestBody.image = {
+          type: 'image_url',
+          url: params.imageUrl,
+        };
+      } else if (hasImageUrls && params.imageUrls) {
+        requestBody.images = params.imageUrls.map((url) => ({
+          type: 'image_url',
+          url,
+        }));
+      }
+    }
+
+    log('Calling XAI image API: %s with body: %O', endpoint, requestBody);
+
+    const response = await fetch(endpoint, {
+      body: JSON.stringify(requestBody),
+      headers: {
+        'Authorization': `Bearer ${apiKey}`,
+        'Content-Type': 'application/json',
+      },
+      method: 'POST',
+    });
+
+    if (!response.ok) {
+      let errorData;
+      try {
+        errorData = await response.json();
+      } catch {
+        // Failed to parse JSON error response
+      }
+
+      throw new Error(
+        `XAI API error (${response.status}): ${errorData?.error?.message || response.statusText}`,
+      );
+    }
+
+    const data: XAIImageResponse = await response.json();
+
+    log('Image generation response: %O', data);
+
+    if (!data.data || data.data.length === 0) {
+      throw new Error('No images generated in response');
+    }
+
+    const imageUrl = data.data[0].url;
+
+    if (!imageUrl) {
+      throw new Error('No valid image URL in response');
+    }
+
+    log('Image generated successfully: %s', imageUrl);
+
+    return { imageUrl };
+  } catch (error) {
+    log('Error in createXAIImage: %O', error);
+
+    throw AgentRuntimeError.createImage({
+      error: error as any,
+      errorType: 'ProviderBizError',
+      provider,
+    });
+  }
+}
diff --git a/packages/model-runtime/src/providers/xai/index.ts b/packages/model-runtime/src/providers/xai/index.ts
index 5aaf7dc3c0..da6ffc843b 100644
--- a/packages/model-runtime/src/providers/xai/index.ts
+++ b/packages/model-runtime/src/providers/xai/index.ts
@@ -2,6 +2,7 @@ import { ModelProvider } from 'model-bank';
 
 import { createOpenAICompatibleRuntime } from '../../core/openaiCompatibleFactory';
 import { MODEL_LIST_CONFIGS, processModelList } from '../../utils/modelParse';
+import { createXAIImage } from './createImage';
 
 export interface XAIModelCard {
   id: string;
@@ -14,6 +15,7 @@ export const isGrokReasoningModel = (model: string) =>
 
 export const LobeXAI = createOpenAICompatibleRuntime({
   baseURL: 'https://api.x.ai/v1',
+  createImage: createXAIImage,
   chatCompletion: {
     handlePayload: (payload) => {
       const { enabledSearch, frequency_penalty, model, presence_penalty, ...rest } = payload;
