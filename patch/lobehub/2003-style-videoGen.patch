diff --git a/packages/model-bank/src/aiModels/volcengine.ts b/packages/model-bank/src/aiModels/volcengine.ts
index 0dce5350734..4ff36c4288e 100644
--- a/packages/model-bank/src/aiModels/volcengine.ts
+++ b/packages/model-bank/src/aiModels/volcengine.ts
@@ -1,4 +1,31 @@
-import { type AIChatModelCard, type AIImageModelCard } from '../types/aiModel';
+import {
+  PRESET_VIDEO_ASPECT_RATIOS,
+  PRESET_VIDEO_RESOLUTIONS,
+  type VideoModelParamsSchema,
+} from '../standard-parameters/video';
+import {
+  type AIChatModelCard,
+  type AIImageModelCard,
+  type AIVideoModelCard,
+} from '../types/aiModel';
+
+export const seedance15ProParams: VideoModelParamsSchema = {
+  aspectRatio: {
+    default: 'adaptive',
+    enum: ['adaptive', ...PRESET_VIDEO_ASPECT_RATIOS],
+  },
+  cameraFixed: { default: false },
+  duration: { default: 5, max: 12, min: 4 },
+  endImageUrl: { default: null, maxFileSize: 30 * 1024 * 1024, requiresImageUrl: true },
+  generateAudio: { default: true },
+  imageUrl: { default: null, maxFileSize: 30 * 1024 * 1024 },
+  prompt: { default: '' },
+  resolution: {
+    default: '720p',
+    enum: PRESET_VIDEO_RESOLUTIONS,
+  },
+  seed: { default: null },
+};
 
 // https://www.volcengine.com/docs/82379/1330310
 
@@ -1227,6 +1254,19 @@ const volcengineImageModels: AIImageModelCard[] = [
   },
 ];
 
-export const allModels = [...doubaoChatModels, ...volcengineImageModels];
+export const volcengineVideoModels: AIVideoModelCard[] = [
+  {
+    description:
+      'Seedance 1.5 Pro by ByteDance supports text-to-video, image-to-video (first frame, first+last frame), and audio generation synchronized with visuals.',
+    displayName: 'Seedance 1.5 Pro',
+    enabled: true,
+    id: 'doubao-seedance-1-5-pro-251215',
+    parameters: seedance15ProParams,
+    releasedAt: '2025-12-15',
+    type: 'video',
+  },
+];
+
+export const allModels = [...doubaoChatModels, ...volcengineImageModels, ...volcengineVideoModels];
 
 export default allModels;
diff --git a/packages/model-bank/src/aiModels/xai.ts b/packages/model-bank/src/aiModels/xai.ts
index 6268e104d34..3b5fe2d8c68 100644
--- a/packages/model-bank/src/aiModels/xai.ts
+++ b/packages/model-bank/src/aiModels/xai.ts
@@ -1,4 +1,4 @@
-import type { AIChatModelCard, AIImageModelCard } from '../types/aiModel';
+import type { AIChatModelCard, AIImageModelCard, AIVideoModelCard } from '../types/aiModel';
 
 // https://docs.x.ai/docs/models
 const xaiChatModels: AIChatModelCard[] = [
@@ -392,6 +392,31 @@ const xaiImageModels: AIImageModelCard[] = [
   },
 ];
 
-export const allModels = [...xaiChatModels, ...xaiImageModels];
+const xaiVideoModels: AIVideoModelCard[] = [
+  {
+    description:
+      'Generate videos from text prompts or animate still images. Supports configurable duration, aspect ratio, and resolution.',
+    displayName: 'Grok Imagine Video',
+    enabled: true,
+    id: 'grok-imagine-video',
+    parameters: {
+      aspectRatio: {
+        default: '16:9',
+        enum: ['16:9', '9:16', '1:1', '4:3', '3:4', '3:2', '2:3'],
+      },
+      duration: { default: 5, max: 15, min: 1 },
+      imageUrl: { default: null },
+      prompt: { default: '' },
+      resolution: {
+        default: '480p',
+        enum: ['480p', '720p'],
+      },
+    },
+    releasedAt: '2026-01-28',
+    type: 'video',
+  },
+];
+
+export const allModels = [...xaiChatModels, ...xaiImageModels, ...xaiVideoModels];
 
 export default allModels;
diff --git a/packages/model-runtime/src/providers/xai/index.ts b/packages/model-runtime/src/providers/xai/index.ts
index da6ffc843b3..3e6ee4ffc0d 100644
--- a/packages/model-runtime/src/providers/xai/index.ts
+++ b/packages/model-runtime/src/providers/xai/index.ts
@@ -3,6 +3,7 @@ import { ModelProvider } from 'model-bank';
 import { createOpenAICompatibleRuntime } from '../../core/openaiCompatibleFactory';
 import { MODEL_LIST_CONFIGS, processModelList } from '../../utils/modelParse';
 import { createXAIImage } from './createImage';
+import { createXAIVideo } from './video/createVideo';
 
 export interface XAIModelCard {
   id: string;
@@ -16,6 +17,7 @@ export const isGrokReasoningModel = (model: string) =>
 export const LobeXAI = createOpenAICompatibleRuntime({
   baseURL: 'https://api.x.ai/v1',
   createImage: createXAIImage,
+  createVideo: createXAIVideo,
   chatCompletion: {
     handlePayload: (payload) => {
       const { enabledSearch, frequency_penalty, model, presence_penalty, ...rest } = payload;
diff --git a/packages/model-runtime/src/providers/xai/video/createVideo.test.ts b/packages/model-runtime/src/providers/xai/video/createVideo.test.ts
new file mode 100644
index 00000000000..c1a935a7829
--- /dev/null
+++ b/packages/model-runtime/src/providers/xai/video/createVideo.test.ts
@@ -0,0 +1,258 @@
+import { beforeEach, describe, expect, it, vi } from 'vitest';
+
+import type { CreateVideoOptions } from '../../../core/openaiCompatibleFactory';
+import type { CreateVideoPayload } from '../../../types/video';
+import { createXAIVideo } from './createVideo';
+
+vi.mock('debug', () => ({
+  default: vi.fn(() => vi.fn()),
+}));
+
+const mockFetch = vi.fn();
+vi.stubGlobal('fetch', mockFetch);
+
+describe('createXAIVideo', () => {
+  let payload: CreateVideoPayload;
+  let options: CreateVideoOptions;
+
+  beforeEach(() => {
+    vi.clearAllMocks();
+
+    payload = {
+      model: 'grok-imagine-video',
+      params: {
+        prompt: 'a beautiful sunset over ocean',
+      },
+    };
+
+    options = {
+      apiKey: 'test-api-key',
+      provider: 'xai',
+    };
+  });
+
+  describe('successful creation', () => {
+    it('should return inferenceId and videoUrl on success', async () => {
+      mockFetch
+        .mockResolvedValueOnce({
+          json: () => Promise.resolve({ request_id: 'req-abc-123' }),
+          ok: true,
+        })
+        .mockResolvedValue({
+          json: () =>
+            Promise.resolve({
+              model: 'grok-imagine-video',
+              video: {
+                url: 'https://example.com/video.mp4',
+                duration: 5,
+                respect_moderation: true,
+              },
+            }),
+          ok: true,
+        });
+
+      const result = await createXAIVideo(payload, options);
+
+      expect(result).toEqual({
+        inferenceId: 'req-abc-123',
+        videoUrl: 'https://example.com/video.mp4',
+      });
+    });
+
+    it('should send minimal body with only prompt', async () => {
+      mockFetch
+        .mockResolvedValueOnce({
+          json: () => Promise.resolve({ request_id: 'req-1' }),
+          ok: true,
+        })
+        .mockResolvedValue({
+          json: () =>
+            Promise.resolve({
+              model: 'grok-imagine-video',
+              video: {
+                url: 'https://example.com/video.mp4',
+                duration: 5,
+                respect_moderation: true,
+              },
+            }),
+          ok: true,
+        });
+
+      await createXAIVideo(payload, options);
+
+      const fetchCall = mockFetch.mock.calls[0];
+      const body = JSON.parse(fetchCall[1].body);
+
+      expect(body.prompt).toBe('a beautiful sunset over ocean');
+      expect(body.model).toBe('grok-imagine-video');
+      // Should not include optional params
+      expect(body.aspect_ratio).toBeUndefined();
+      expect(body.duration).toBeUndefined();
+      expect(body.resolution).toBeUndefined();
+    });
+  });
+
+  describe('image support', () => {
+    it('should add image when imageUrl is provided', async () => {
+      mockFetch
+        .mockResolvedValueOnce({
+          json: () => Promise.resolve({ request_id: 'req-1' }),
+          ok: true,
+        })
+        .mockResolvedValue({
+          json: () =>
+            Promise.resolve({
+              model: 'grok-imagine-video',
+              video: {
+                url: 'https://example.com/video.mp4',
+                duration: 5,
+                respect_moderation: true,
+              },
+            }),
+          ok: true,
+        });
+
+      payload.params.imageUrl = 'https://example.com/start.jpg';
+
+      await createXAIVideo(payload, options);
+
+      const body = JSON.parse(mockFetch.mock.calls[0][1].body);
+      expect(body.image).toEqual({
+        url: 'https://example.com/start.jpg',
+      });
+    });
+  });
+
+  describe('optional params', () => {
+    beforeEach(() => {
+      mockFetch
+        .mockResolvedValueOnce({
+          json: () => Promise.resolve({ request_id: 'req-1' }),
+          ok: true,
+        })
+        .mockResolvedValue({
+          json: () =>
+            Promise.resolve({
+              model: 'grok-imagine-video',
+              video: {
+                url: 'https://example.com/video.mp4',
+                duration: 5,
+                respect_moderation: true,
+              },
+            }),
+          ok: true,
+        });
+    });
+
+    it('should map aspectRatio to body.aspect_ratio', async () => {
+      payload.params.aspectRatio = '9:16';
+      await createXAIVideo(payload, options);
+      const body = JSON.parse(mockFetch.mock.calls[0][1].body);
+      expect(body.aspect_ratio).toBe('9:16');
+    });
+
+    it('should map duration to body.duration', async () => {
+      payload.params.duration = 10;
+      await createXAIVideo(payload, options);
+      const body = JSON.parse(mockFetch.mock.calls[0][1].body);
+      expect(body.duration).toBe(10);
+    });
+
+    it('should map resolution to body.resolution', async () => {
+      payload.params.resolution = '720p';
+      await createXAIVideo(payload, options);
+      const body = JSON.parse(mockFetch.mock.calls[0][1].body);
+      expect(body.resolution).toBe('720p');
+    });
+  });
+
+  describe('client config', () => {
+    beforeEach(() => {
+      mockFetch
+        .mockResolvedValueOnce({
+          json: () => Promise.resolve({ request_id: 'req-1' }),
+          ok: true,
+        })
+        .mockResolvedValue({
+          json: () =>
+            Promise.resolve({
+              model: 'grok-imagine-video',
+              video: {
+                url: 'https://example.com/video.mp4',
+                duration: 5,
+                respect_moderation: true,
+              },
+            }),
+          ok: true,
+        });
+    });
+
+    it('should use default baseURL', async () => {
+      await createXAIVideo(payload, options);
+
+      const fetchUrl = mockFetch.mock.calls[0][0];
+      expect(fetchUrl).toBe('https://api.x.ai/v1/videos/generations');
+    });
+
+    it('should use custom baseURL when provided', async () => {
+      options.baseURL = 'https://custom-endpoint.com/v1';
+      await createXAIVideo(payload, options);
+
+      const fetchUrl = mockFetch.mock.calls[0][0];
+      expect(fetchUrl).toBe('https://custom-endpoint.com/v1/videos/generations');
+    });
+
+    it('should send Authorization Bearer header', async () => {
+      await createXAIVideo(payload, options);
+
+      const fetchHeaders = mockFetch.mock.calls[0][1].headers;
+      expect(fetchHeaders['Authorization']).toBe('Bearer test-api-key');
+      expect(fetchHeaders['Content-Type']).toBe('application/json');
+    });
+  });
+
+  describe('error handling', () => {
+    it('should throw on HTTP error', async () => {
+      mockFetch.mockResolvedValue({
+        ok: false,
+        status: 429,
+        text: () => Promise.resolve('Rate limit exceeded'),
+      });
+
+      await expect(createXAIVideo(payload, options)).rejects.toThrow(
+        'XAI video API error: 429 Rate limit exceeded',
+      );
+    });
+
+    it('should throw when response has no request_id', async () => {
+      mockFetch.mockResolvedValue({
+        json: () => Promise.resolve({}),
+        ok: true,
+      });
+
+      await expect(createXAIVideo(payload, options)).rejects.toThrow(
+        'Invalid response: missing request_id',
+      );
+    });
+
+    it('should throw when video generation fails with error response', async () => {
+      mockFetch
+        .mockResolvedValueOnce({
+          json: () => Promise.resolve({ request_id: 'req-1' }),
+          ok: true,
+        })
+        .mockResolvedValue({
+          json: () =>
+            Promise.resolve({
+              code: 'Unrecoverable data loss or corruption',
+              error: 'Fetching image failed with HTTP status 403 Forbidden.',
+            }),
+          ok: true,
+        });
+
+      await expect(createXAIVideo(payload, options)).rejects.toThrow(
+        'Fetching image failed with HTTP status 403 Forbidden.',
+      );
+    });
+  });
+});
diff --git a/packages/model-runtime/src/providers/xai/video/createVideo.ts b/packages/model-runtime/src/providers/xai/video/createVideo.ts
new file mode 100644
index 00000000000..6423ccc28e2
--- /dev/null
+++ b/packages/model-runtime/src/providers/xai/video/createVideo.ts
@@ -0,0 +1,172 @@
+import createDebug from 'debug';
+
+import type { CreateVideoOptions } from '../../../core/openaiCompatibleFactory';
+import type { CreateVideoPayload } from '../../../types/video';
+import { asyncifyPolling } from '../../../utils/asyncifyPolling';
+
+const log = createDebug('lobe-video:xai');
+
+interface XAIVideoGenerationResponse {
+  request_id: string;
+}
+
+interface XAIVideoStatusResponse {
+  code?: string;
+  error?: string;
+  model?: string;
+  video?: {
+    url?: string;
+    duration?: number;
+    respect_moderation?: boolean;
+  };
+}
+
+interface XAIVideoRequestBody {
+  aspect_ratio?: string;
+  duration?: number;
+  image?: {
+    url: string;
+  };
+  model: string;
+  prompt: string;
+  resolution?: '720p' | '480p';
+}
+
+interface PollingResult {
+  error?: string;
+  status: 'pending' | 'done' | 'failed';
+  videoUrl?: string;
+}
+
+/**
+ * Query XAI video generation status by request_id
+ */
+async function queryVideoStatus(
+  requestId: string,
+  apiKey: string,
+  baseURL: string,
+): Promise<XAIVideoStatusResponse> {
+  const response = await fetch(`${baseURL}/videos/${requestId}`, {
+    headers: {
+      Authorization: `Bearer ${apiKey}`,
+    },
+    method: 'GET',
+  });
+
+  if (!response.ok) {
+    const errorText = await response.text();
+    log('XAI video status query error: %s %s', response.status, errorText);
+    throw new Error(`XAI video status query error: ${response.status} ${errorText}`);
+  }
+
+  return (await response.json()) as XAIVideoStatusResponse;
+}
+
+/**
+ * XAI video generation implementation with polling
+ * API docs: https://docs.x.ai/docs/video-generation
+ * Returns both inferenceId and videoUrl (for async processing)
+ */
+export async function createXAIVideo(
+  payload: CreateVideoPayload,
+  options: CreateVideoOptions,
+): Promise<{ inferenceId: string; videoUrl: string }> {
+  const { model, params } = payload;
+  const { apiKey, provider } = options;
+  const { prompt, imageUrl, aspectRatio, duration, resolution } = params;
+
+  log('Creating video with XAI API - model: %s, params: %O', model, params);
+
+  const baseURL = options.baseURL || 'https://api.x.ai/v1';
+
+  // Build request body
+  const body: XAIVideoRequestBody = {
+    model,
+    prompt,
+  };
+
+  if (aspectRatio !== undefined) {
+    body.aspect_ratio = aspectRatio;
+  }
+
+  if (duration !== undefined && duration >= 1 && duration <= 15) {
+    body.duration = duration;
+  }
+
+  if (imageUrl) {
+    body.image = {
+      url: imageUrl,
+    };
+  }
+
+  if (resolution) {
+    body.resolution = resolution as '720p' | '480p';
+  }
+
+  log('XAI video API request body: %s', JSON.stringify(body, null, 2));
+
+  // Step 1: Submit video generation request
+  const response = await fetch(`${baseURL}/videos/generations`, {
+    body: JSON.stringify(body),
+    headers: {
+      'Authorization': `Bearer ${apiKey}`,
+      'Content-Type': 'application/json',
+    },
+    method: 'POST',
+  });
+
+  if (!response.ok) {
+    const errorText = await response.text();
+    log('XAI video API error: %s %s', response.status, errorText);
+    throw new Error(`XAI video API error: ${response.status} ${errorText}`);
+  }
+
+  const data = (await response.json()) as XAIVideoGenerationResponse;
+
+  log('XAI video API response: %O', data);
+
+  if (!data?.request_id) {
+    throw new Error('Invalid response: missing request_id');
+  }
+
+  const requestId = data.request_id;
+
+  // Step 2: Poll for video generation status
+  const videoData = await asyncifyPolling<PollingResult, { inferenceId: string; videoUrl: string }>(
+    {
+      checkStatus: (pollingResult: PollingResult) => {
+        if (pollingResult.status === 'done' && pollingResult.videoUrl) {
+          log('Video generation succeeded: %s', requestId);
+          return {
+            data: { inferenceId: requestId, videoUrl: pollingResult.videoUrl },
+            status: 'success',
+          };
+        }
+
+        if (pollingResult.error) {
+          log('Video generation failed: %s, error: %s', requestId, pollingResult.error);
+          return {
+            error: new Error(pollingResult.error),
+            status: 'failed',
+          };
+        }
+
+        return { status: 'pending' };
+      },
+      logger: {
+        debug: (message: any, ...args: any[]) => log(message, ...args),
+        error: (message: any, ...args: any[]) => log(message, ...args),
+      },
+      maxConsecutiveFailures: 10,
+      maxRetries: 60, // 60 retries = up to 5 minutes
+      pollingQuery: () =>
+        queryVideoStatus(requestId, apiKey, baseURL).then((response) => ({
+          error: response.error,
+          status: response.video?.url ? 'done' : 'pending',
+          videoUrl: response.video?.url,
+        })),
+    },
+  );
+
+  return videoData;
+}
diff --git a/src/app/[variants]/(main)/home/_layout/Header/components/Nav.tsx b/src/app/[variants]/(main)/home/_layout/Header/components/Nav.tsx
index b2da62adddf..a5656346c25 100644
--- a/src/app/[variants]/(main)/home/_layout/Header/components/Nav.tsx
+++ b/src/app/[variants]/(main)/home/_layout/Header/components/Nav.tsx
@@ -10,11 +10,7 @@ import { getRouteById } from '@/config/routes';
 import { useActiveTabKey } from '@/hooks/useActiveTabKey';
 import { useGlobalStore } from '@/store/global';
 import { SidebarTabKey } from '@/store/global/initialState';
-import {
-  featureFlagsSelectors,
-  serverConfigSelectors,
-  useServerConfigStore,
-} from '@/store/serverConfig';
+import { featureFlagsSelectors, useServerConfigStore } from '@/store/serverConfig';
 
 import { type NavItemProps } from '../../../../../../../features/NavPanel/components/NavItem';
 import NavItem from '../../../../../../../features/NavPanel/components/NavItem';
@@ -35,7 +31,6 @@ const Nav = memo(() => {
   const { t } = useTranslation('common');
   const toggleCommandMenu = useGlobalStore((s) => s.toggleCommandMenu);
   const { showMarket, showAiImage } = useServerConfigStore(featureFlagsSelectors);
-  const enableBusinessFeatures = useServerConfigStore(serverConfigSelectors.enableBusinessFeatures);
 
   const items: Item[] = useMemo(
     () => [
@@ -60,7 +55,6 @@ const Nav = memo(() => {
         url: '/page',
       },
       {
-        hidden: !enableBusinessFeatures,
         icon: getRouteById('video')!.icon,
         isNew: true,
         key: SidebarTabKey.Video,
